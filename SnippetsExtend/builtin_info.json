{
    "version": "2020.26630",
    "CHOP": {
        "analyzeCHOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "function",
                    "author": "",
                    "readme": {
                        "en": "These examples show the different functions of the Analyze CHOP."
                    }
                },
                "1": {
                    "title": "no peak",
                    "author": "",
                    "readme": {
                        "en": "This Analyze CHOP becomes -1 when there are no peaks in the input number."
                    }
                },
                "2": {
                    "title": "RMS",
                    "author": "",
                    "readme": {
                        "en": "These two examples get the RMS (Root Mean Squared) values of both the incoming Noise CHOP, and even more useful, for the incoming audio file. \n\nRMS is a way of measuring \"power\" of a signal, and is similar to amplitude, but favors the peaks.\n\nThe viewer of audiofilein1 is fixed at a range of -1 to 1 because of Viewer Active -> rclick -> Vertical Range set to -1 to +1."
                    }
                },
                "3": {
                    "title": "valid signal",
                    "author": "",
                    "readme": {
                        "en": "These two examples will analyze, in this case a series of pulses to detect when the input signal is on (value 1) for a continuous .6 seconds.\n\nThe first is do-it-yourself where you can nervously tap the button and nothing happens in trigger2. But if you hold \n\nIt is useful for filtering out jittery inputs from inexact devices like Kinect or Leap. \n\nAnalyze looks for the minimum value over .6 seconds, and if all samples over the last .6 seconds are above zero, the Trigger CHOP is triggerd. \n\nThe Trigger CHOP assures the output signal stays on for at least a definitive 2 seconds, and when Analyze goes to 0, the output signal stays on for an additional 1.5 seconds and then drops to 0 during 1 more second. Asjust all these parameters to taste.\n\nYou can unbypass the Filter CHOP to be more lenient: the input signal can drop to 0 for up to .2 seconds.\n\nYou can bypass the Logic CHOP to work with more raw analog data.\n\nNote the Filter CHOP is not Time Sliced - it's filtering the entire .6 seconds each frame it cooks."
                    }
                },
                "4": {
                    "title": "adaptive calibrate zone",
                    "author": "",
                    "readme": {
                        "en": "This keeps the XY range between 0 and 1, whether you are moving the input slightly or in a wide range.\n\nThe Analyze CHOPs get the maximum and minimum values for X and Y over the past 10 seconds (Trail CHOP is set to 10 sec).\n\nThen the math_rangeX and math_rangeY CHOPs re-range the max/min so the values go from 0 to 1.\n\nIf you want to fix the max/min range, just lock the Trail CHOPs or the Analyze CHOPs right after you move the inputs around to the XY full range that you want to operate in.\n\nIf you want it adaptive over the last 20 seconds, unlock the Trail CHOPs and then unbypass the Lag CHOPs. It gives it an 10 extra seconds to blend to new max/min values. See their Clamp Slope values.\n\nThe math_*Bump* CHOPs make sure that when the inputs go silent, the output is .5.\n\nprops to elburz for original concept.\n\nTrail CHOPs have fixed range of -1 to +1 via the graph Viewer Active rclick menu."
                    }
                }
            }
        },
        "audiobandeqCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "bandeq",
                    "author": "",
                    "readme": {
                        "en": "Draw on the 'multilevel' graph. It sets the band EQ levels.\n\nThe center level is the 0-gain (default pass-through)."
                    }
                }
            }
        },
        "audiodeviceinCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "audio in",
                    "author": "",
                    "readme": {
                        "en": "Choose your preferred input device in\naudiodevicein1 and then click the Audio On/Off button.\n\nWARNING: If you're using a built in laptop speakers and microphone, this example will feedback quickly."
                    }
                }
            }
        },
        "audiodeviceoutCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "volume pops",
                    "author": "",
                    "readme": {
                        "en": "Making audio not pop when you adjust volume is a necessity. If you just attach a slider to a Math CHOP (via export, expression, or as an input to the Math CHOP), will make it pop as the audio samples jump from say .7 to .4 in one step.\n\nTo demonstrate popping, bypass timeslice1 and play with adjustSlider. Then un-bypass timeslice1 and ply with adjustSlider.\n\nThis method interpolates the volume control of the audio rate (735 samples per frame (T 60 Hz)), meaning that at the start of a frame it is v0 and at the end of aframe, 735 samples later it is v1. WHen thisn is multiplied against the audio wave, then the audio wave rises or falls cloothly over  the course of 1/60 seconds.\n\nTimeslice is set to interploate the  slider linearly.\n\nAudio Device Out is set to NOT cook every frame so when you are not looking at this demo, it's not outputting audio."
                    }
                },
                "1": {
                    "title": "audiodevout optimize",
                    "author": "",
                    "readme": {
                        "en": "This uses a script to turn off/on the Active parameter of the Audio Device Out CHOP, which stops all cooking upstream when this network is not being displayed (like when you are in Perform Mode).  It's most optimized that when Volume is 0, that you turn Active off too.\n\nYou can also turn Active off/on too by exporting 0 or 1 to that parameter."
                    }
                }
            }
        },
        "audiodynamicsCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "mix sounds",
                    "author": "",
                    "readme": {
                        "en": "WHen you mix multiple sounds together, it is likely that you will exceed values -1 to + 1.\n\nUnbypass audiodyn1.\n\nIn this case we are simply adding left-right channels of 2 sources into 1 channel, and applying a gain to the sonar sound.\n\nBypass audiodyna1 to hear the overloaded mix. \n\nAudio Dynamics manages it down to -1 to +1. "
                    }
                },
                "1": {
                    "title": "crank to max",
                    "author": "",
                    "readme": {
                        "en": "Push audio at low levels to be always loud. First push the amplitude high, then the Audio Dynamics manage it down to -1 to +1.\n\nThe volume is artificially being pushed up and down by the LFO CHOP.\n\nListen to select1 (bypass audiodyn1) to see how much the levels are varying. Then listen again to audiodyn1.\n\nThe info1 CHOP shows how much the audio is being compressed and limited."
                    }
                }
            }
        },
        "audiofileinCHOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "sequential mode",
                    "author": "",
                    "readme": {
                        "en": "This audio file will play itself regardless of the main timeline.\n\nTurn on Active to hear it."
                    }
                },
                "1": {
                    "title": "locked to timeline",
                    "author": "",
                    "readme": {
                        "en": "This audio file's index is locked to the main timeline.\n\nTurn on Active to hear it.\n\nTry scrubbing through the timeline while listening to the audio.\n\nWe use the timeline less these days, and prefer Sequential or Specify Index."
                    }
                },
                "2": {
                    "title": "specify index",
                    "author": "",
                    "readme": {
                        "en": "This audio file's index is being manually driven by the Speed CHOP.\n\nTurn on Active to hear it.\n\nThe Speed CHOP is counting up by 1 every second, which plays the audio at normal speed."
                    }
                },
                "3": {
                    "title": "play cue",
                    "author": "",
                    "readme": {
                        "en": "This is an example of how to cue and play and audio file.  It cues to 3 seconds into the file."
                    }
                },
                "4": {
                    "title": "trim",
                    "author": "",
                    "readme": {
                        "en": "The trimming function here keeps the audio file looping between seconds 4 and 5 of the file, which is 44100 samples long once it's trimmed.\n\nThe file itself is not changed."
                    }
                },
                "5": {
                    "title": "control",
                    "author": "",
                    "readme": {
                        "en": "Glitchless volume:\n\nEnsure your 60fps volume channel has the same rate and time interval as  the audio time slice, then multiply.\n\nPress 'Listen' to send to default audio output device. Wiggle volume slider.\n\nBypass resample1 to observe original steppy results.\n\n "
                    }
                }
            }
        },
        "audiofilterCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "opposite filters",
                    "author": "",
                    "readme": {
                        "en": "One ear hears what the other doesn't.\n\nConnect merge_opp1 to the Audio Device Out, move slider. Left is the opposite part of the spectrum vs right.\n\nConnect merge_opp2 to the Audio Device Out, move slider.  Part of the spectrum is moved to the opposite ear,"
                    }
                },
                "1": {
                    "title": "hi freq cutoff",
                    "author": "",
                    "readme": {
                        "en": "The second input on the Audio Filter CHOP is used to drive some parameters at higher frequency than an exported CHOP can on the parameter, or a CHOP expression. These are limited by the frame rate of the timeline, default 60. \n\nIf you want to modulate the cutoff frequency at say 1000 cycles per second, you need to feed the Audio Filter CHOP's second input a channel that's called cutofffrequency, at a high sample rate. In the case of the LFO CHOP, it is set to 8000 samples per second, and as you can see from the graph, there are about 120 samples per frame.\n\nThis distorts the audio a lot, pleasing at some combinations of the 2 sliders and the Filter Cutoff parameter of teh Audio Filter CHOP.\n\nThen send audioosci_sine to the filter via null1.\n\nTry it wuth LFO set to a Square Wave.\n\nIf you are up for it, try the white noise in the Audio Oscillator CHOP."
                    }
                }
            }
        },
        "audiooscillatorCHOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "waveforms",
                    "author": "",
                    "readme": {
                        "en": "Try the various waveforms (Type) and various Base Frequencies. (First un-bypass the Audio Device Out CHOP.)\n\nTry -2, -1, 0, 1, 2 in the Constant CHOP. Each step is an octave relative to the Base Frequency.\n\nThen try 0, 1/12, 2/12 etc in the Constant CHOP - each step of 1/12 is a \"semitone\" higher than its predecessor (one note up on a conventional keyboard). 12/12 = 1 is an octave, helping to de-mystify the 12-note scale.\n\n7/12 is 7 semitones, called a \"fifth\", and is almost 50% higher in frequency than the Base Frequency, giving it a pleasant relation to the base frequency, and pleasant to the ear.\n\nConnecting lag1 to the oscillator first input gives a 2-octave glissando."
                    }
                },
                "1": {
                    "title": "white and pink noise",
                    "author": "",
                    "readme": {
                        "en": "Audio Oscillator generates fully random (white) noise.\n\nThen to get \"pink\" noise, you need to filter it and remove some frequencies."
                    }
                },
                "2": {
                    "title": "oscillator",
                    "author": "",
                    "readme": {
                        "en": "Simple example routing a sine wave to an Audio Device Out CHOP.\n\nAlso has sliders to control pitch and alising. \n\nThis uses a script to turn off/on the Active parameter of the Audio Device Out CHOP, which stops all cooking upstream when this network is not being displayed (like when you are in Perform Mode).  See the Audio Device Out CHOP snippets."
                    }
                },
                "3": {
                    "title": "playback source",
                    "author": "",
                    "readme": {
                        "en": "The oscillator here samples and loops a small portion of the input file."
                    }
                },
                "4": {
                    "title": "envelope",
                    "author": "",
                    "readme": {
                        "en": "Click Trigger Pulse on trigger1."
                    }
                },
                "5": {
                    "title": "frequehncy in",
                    "author": "",
                    "readme": {
                        "en": "If you want the input to be the frequency in Hz, you have to convert it to octaves.\n\nTher octave is log to the base 2 of the frequency divided by the base frequency in the Audio Oscillator CHOP:   \n\nlog((freq/440), 2.)\n\nThe rename is not needed."
                    }
                }
            }
        },
        "audioparaeqCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "djmix",
                    "author": "",
                    "readme": {
                        "en": "typical dj mixer filter\n"
                    }
                }
            }
        },
        "audiorenderCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "source and listener",
                    "author": "",
                    "readme": {
                        "en": "You feed an audio channel to Audio Render, it is associated with the Source object's position (the throbbing sphere), and it will generate the number of channels that is implicitly requested... binaual and stereo are two channels, for example."
                    }
                }
            }
        },
        "audiospectrumCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "spectrum1",
                    "author": "",
                    "readme": {
                        "en": "audiospect_nice in enhanced for viewing.\n\nTHe CHOPs after it are 3 ways to get accurate or approximate averages for the spectrum split into 10 bands.\n\naudiospect_raw is accurate and has additional property that it corresponds to 1 Hz per sample. So sample 5000 is the level at 5000 Hz. Its graph displys in samples in x.\n\naudiospect3 goes to frequency and audiospect4 re-constructs the audio signal with virtually no error."
                    }
                }
            }
        },
        "beatCHOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "bar",
                    "author": "",
                    "readme": {
                        "en": "Produces a ramp that spans the bar and a pulse at the beginning of the bar"
                    }
                },
                "1": {
                    "title": "beat",
                    "author": "",
                    "readme": {
                        "en": "Produces a sine wave that completes a full cycle over the coarse of a bar.\n\nThe 'count' counts upward for every bar that passes."
                    }
                },
                "2": {
                    "title": "bar1",
                    "author": "",
                    "readme": {
                        "en": "The 'bar' counts up on start of the bar.\n\n'Beat' counts the number of breatsin a bar and loops back to 0 when the bar is complete."
                    }
                },
                "3": {
                    "title": "offset",
                    "author": "",
                    "readme": {
                        "en": "You're able to make multiple channels of the same output and then offest each one by a varying degree."
                    }
                },
                "4": {
                    "title": "reset",
                    "author": "",
                    "readme": {
                        "en": "Resetting a Beat CHOP. You can also export to the Reset pulse parameter."
                    }
                }
            }
        },
        "blendCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "blend",
                    "author": "",
                    "readme": {
                        "en": "In a Blend CHOP, the multiple  channels of input 1 are the blend weights for all the other inputs.\n\nIn this example the sliders control how much each wave will be taken into account during the blend. \n\nIn Proportianal, all three waves are blended proportionally, so you  always get a value between the three waves. When all three weights are 0,  it give a discontinuous result when one goes off-zero.\n\nWith Differencing, it is preferable in  most cases. With weights at 0, it starts with the first wave and the other 2 channels are added to it depending on the the weighting channels.\n\nThe Trim CHOPs make the weight channels 600 samples long (10 seconds) like the 3 wave CHOPs, as waves and weights are blended sample-by-sample.\n\nExperiment with different values and watch the output wave."
                    }
                }
            }
        },
        "blobtrackCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "1D motion",
                    "author": "",
                    "readme": {
                        "en": "fakeData1 simulates an object moving back and forth in X in a rectangle -5 to +5.\n\nIt simulates what a scanner would see from a distant point in -Y where one object is being occluded by another object.\n\nblobRender1 shows the process. The blob area in the Area of Interest, defined by the boulding box corner parameters.\n\nWhite is a dot for every X Y sample. fakeData1_ is 1000 samples long.\n\nThe red dots are the centers of the detected blobs that are output from the CHOP. \n\nThe red lines are actually boxes surrounding the points that are associated with the blob.\n\nThe white lines at the top are excluded from the blob detection because they are outside the blob bounding box.\n\nLost Blob Timeout was increased to alow for one blob going behind the other."
                    }
                },
                "1": {
                    "title": "2D motion",
                    "author": "",
                    "readme": {
                        "en": "This is the kind of data one would expect from a radial scanner when the data is converted from its (distance, angle) form into a (x, y) form.\n\nBecause the moving blob is going in a curved path, Max Blob Movement had to be raised to qualify as the same blob that went behind the stationary blob.\n\n(fakeData1 here is the same as fakeData1 in example1 but with radial toggle turned on.)"
                    }
                }
            }
        },
        "clipblenderCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "clipblencer basics",
                    "author": "jarrett",
                    "readme": {
                        "en": "This is an example of the clipblender working with the clip CHOP.  The clipblender is an animation clip player.  It loads animation from only clip CHOPs.\n\nYou will see Quaternion attributes are applied if you look at the info for a clip CHOP vs it's input.\n\nThe animation clips are retrieved from the humanoid FBX archive.\n\nThe clipblender CHOP references an empty table DAT called sequence.  \n\nThe clipblender works by reading the sequence DAT when its contents change - particularly when an row is added.  The row must contain a valid path to a clipCHOP.  When a valid clipCHOP is found with  animation The clipblender CHOP will load that new clip and blend it with the currently playing clip.  When the new clip has played through the clipBlender will look again in the sequence DAT for another clip to play.  If it doesnt find one then it will continuously loop the new clip until another clip request is made.\n\nTo see this in action run the runAnimSequence dat. - Right click on the DAT and select Run Script from pop menu or just press CTRL R.\n\nThe animation in this FBX example is not correctly setup for blending so the animation has discontinuties and is not blending.\n\n\n----\n\nAlternalte descriptopn:\nThe \"clipblender CHOP\" has the ability to read animation data that is stored in \"clip CHOP\"s.  \n\nThe clipblender CHOP requires a default animation to start.  This default animation will be loaded and played in a loop until the clipblender receives a request to play a new clip.\n\nNew clip requests may be sent to the clipblender CHOP using a table DAT that contains a column of clip names, which server as a playlist for the clipblender to consume. When the table DAT - which in this example is called \"sequence\" - contains rows, and the clipblender is reaching the end of the clip it is currently playing, it will look to the DAT list for a next clip to play, which is to be found at the top of the list.\n\nWhen the clipblender CHOP loads the clip listed in DAT list, it will delete that row from the table.  This process will be repeated until the DAT List is empty.  When the DAT List is empty the clipblender will continue to loop the animation clip that it ended up on.\n\nThe python method clipblenderCHOP.trigger() forces the clipblender to look into the DAT List immediately. \n\nTake notice of the \"runAnimSequence\" script DAT. The way this example works, is it will create an animation sequence in the DAT List table - ['clipPunch', 'clipShot', 'clipRun'].\n\nOnce the sequence table is populated with valid clipCHOP names, the clipblender CHOP is triggered and the clipblender CHOP starts consuming clipCHOP names from the sequence table, playing each clip, then consuming the next one, until it empties the table.\n\nThe clipblender will blend the animation based on the Blend Time and Next Blend Time.  The Blend Time is used when the specified clip chop is loaded when the clipblender is triggered.  The next Blend Time is used when the clip is currently being played and is ending and being blended with a new clip.  The current clip's \"Next Blend Time\" length is used to blend out of said clip into a new clip.\n\nThe script can be run over and over to restart the process. \n\n-----\nExtra notes:\n\nThe animation clips are selected out of the humanoid FBX component.  Notice on the Play page the animation parameter has a field drop menu parameter populated with \"run\", \"punch\" and \"shot\".  \n\nThe FBX component Play Mode parameter is set to Output Full Range.  This permits the Import Select CHOP to extract an entire animation clip from the FBX archive.  Therefore animationRun, Punch and Shot are extracted into their own respective Import Select CHOPs.\n\nIts important to note that the clipblender CHOP requires all channels for each clip to match in order and channel name and number of channels. \n\nOn closer inspection the animationRun CHOP has 263 channels while animationPunch and Shot have 353.  Therefore a trim and replace CHOP are used to match the length and channel order and naming for all chops.  Once cleaned and matching the channels are sent into the clip chops and are ready for playback in the clipblender."
                    }
                }
            }
        },
        "clockCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "clock convert",
                    "author": "",
                    "readme": {
                        "en": "This converts seconds to time code break down."
                    }
                }
            }
        },
        "compositeCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "composite pair",
                    "author": "",
                    "readme": {
                        "en": "See Splice CHOP also."
                    }
                }
            }
        },
        "constantCHOP": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "multi channel",
                    "author": "",
                    "readme": {
                        "en": "This example has 2  channels, both defined on the first page."
                    }
                },
                "1": {
                    "title": "pages",
                    "author": "",
                    "readme": {
                        "en": "Some of the channels are on the other pages."
                    }
                },
                "2": {
                    "title": "patterns",
                    "author": "",
                    "readme": {
                        "en": "You can create many channels at once using patterns in the  channel name parameter."
                    }
                },
                "3": {
                    "title": "multi sample",
                    "author": "",
                    "readme": {
                        "en": "This example is 10 samples long, as defined on the Channel page."
                    }
                },
                "4": {
                    "title": "scripting",
                    "author": "",
                    "readme": {
                        "en": "A python expression to set the Constant CHOP value parameter to a certain number.\n\nRight click on textSetValue and select Run Script."
                    }
                },
                "5": {
                    "title": "snapshot",
                    "author": "",
                    "readme": {
                        "en": "This example shows how you can take a snapshot of an incoming value.\n\nTHe Hold CHOP does something similar, without needing a script."
                    }
                },
                "6": {
                    "title": "offset",
                    "author": "",
                    "readme": {
                        "en": "You can offset a Constant CHOP's output value by changes to the values coming in Input 1.\n\nHold down the \"1\" key and then move the mouse in x.\n\nWhile \"1\" is down, any change to the first input  will be added to the output of the CHOP.\n\nWhen the \"1\" key is released, the Constant CHOP output value is stuffed into the parameter value.\n\nThe result is smooth \"relative value\" changes.\n\nThere are a few other ways to do this in CHOPs and DATs."
                    }
                }
            }
        },
        "countCHOP": {
            "num_samples": 11,
            "examples": {
                "0": {
                    "title": "count",
                    "author": "",
                    "readme": {
                        "en": "A simple counting-up example with a reset button."
                    }
                },
                "1": {
                    "title": "input",
                    "author": "",
                    "readme": {
                        "en": "You can count in specific increments by using the 3rd input of the Count CHOP."
                    }
                },
                "2": {
                    "title": "loop",
                    "author": "",
                    "readme": {
                        "en": "An example of looping values."
                    }
                },
                "3": {
                    "title": "clamp",
                    "author": "",
                    "readme": {
                        "en": "This Count CHOP clamps at 10 on the top and 2 on the bottom."
                    }
                },
                "4": {
                    "title": "while on",
                    "author": "",
                    "readme": {
                        "en": "This example counts up while the button is pressed."
                    }
                },
                "5": {
                    "title": "timer",
                    "author": "",
                    "readme": {
                        "en": "This runs a script N seconds after the Start button is pressed.\n\n(The Timer CHOP is easier.)\n\nThis triggers via \"resetpulse\".  The counting starts as soon as Start is pressed, not the frame after the release, as would be with the Reset input or the \"reset\" parameter.\n\nThe script prints \"yes\" to the Dialogs -> Textport after N seconds.\n\nIt doesn't matter what the input to the Count CHOP is - it will always count up, one unit per second - see its parameters."
                    }
                },
                "6": {
                    "title": "time counter",
                    "author": "",
                    "readme": {
                        "en": "You can assign different operations to the different input states.\n\nIn this example, the Count CHOP counts up while the button is off, and then resets when the button is clicked, without using the Reset input on the Count CHOP.\n\nThe Timer CHOP can do this."
                    }
                },
                "7": {
                    "title": "threshold",
                    "author": "",
                    "readme": {
                        "en": "This Count CHOP will only trigger when its threshold has been passed.\n\nIn this example you need to hold the button down until the Filter CHOP has reached .75."
                    }
                },
                "8": {
                    "title": "up and down",
                    "author": "",
                    "readme": {
                        "en": "This setup lets you count both up and down, using only one Count CHOP.\n\nThe 2nd button is subtracted from the first to give the step size: 1 or -1. "
                    }
                },
                "9": {
                    "title": "up and down 2",
                    "author": "",
                    "readme": {
                        "en": "This is an example of having a setup where you're able to count both up and down.\n\nThe setup uses two Count CHOPs that both count upwards, but the 2nd is subtracted from the first. "
                    }
                },
                "10": {
                    "title": "trigger threshold",
                    "author": "",
                    "readme": {
                        "en": "This will filter out pulses that are shorter than a certain amount of time.\n\nThe result will be 1 while an incoming signal has been 1 for a settable amount of time, "
                    }
                }
            }
        },
        "crossCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "slider",
                    "author": "",
                    "readme": {
                        "en": "This is the most basic use of a Cross CHOP to blend between two CHOP values."
                    }
                },
                "1": {
                    "title": "cross",
                    "author": "",
                    "readme": {
                        "en": "The Cross TOP here is blending between the 3 inputs, interpolating the inbetween values."
                    }
                }
            }
        },
        "dattoCHOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "text",
                    "author": "",
                    "readme": {
                        "en": "Grabbing a value from a Text DAT."
                    }
                },
                "1": {
                    "title": "text1",
                    "author": "",
                    "readme": {
                        "en": "Grabbing a channel name from a Text DAT."
                    }
                },
                "2": {
                    "title": "tables",
                    "author": "",
                    "readme": {
                        "en": "Grabbing all the names and values from a table by row."
                    }
                },
                "3": {
                    "title": "select",
                    "author": "",
                    "readme": {
                        "en": "You can selectively choose which parts of a table you'd like to retrieve information from."
                    }
                },
                "4": {
                    "title": "multi sample",
                    "author": "",
                    "readme": {
                        "en": "Grabbing multiple samples from a table and creating channels accordingly."
                    }
                }
            }
        },
        "delayCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "capture changes",
                    "author": "",
                    "readme": {
                        "en": "THis captures changes in values in a CHOP and holds them in a Hold DAT. It uses the Delay CHOP to compare old values with new values. \n\nIt uses the Slope CHOP to detect when the value has changed.\n\nSee also CHOP Execute DAT.\n\nMove sliders in the Constant CHOP."
                    }
                }
            }
        },
        "deleteCHOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "delete chans non scoped",
                    "author": "",
                    "readme": {
                        "en": "This example deletes all the channels that aren't chan[2-4]."
                    }
                },
                "1": {
                    "title": "channel value",
                    "author": "",
                    "readme": {
                        "en": "This example deletes all channels that are within  the range 3.5 and 6.5."
                    }
                },
                "2": {
                    "title": "delete chan constant value",
                    "author": "",
                    "readme": {
                        "en": "This example keeps only channels who have an unchanging, constant value."
                    }
                },
                "3": {
                    "title": "delete see select",
                    "author": "",
                    "readme": {
                        "en": "See the Select CHOP, as it thins out channels too."
                    }
                },
                "4": {
                    "title": "delete samples1",
                    "author": "",
                    "readme": {
                        "en": "See the Select CHOP, as it thins out channels too."
                    }
                },
                "5": {
                    "title": "caterpillar",
                    "author": "",
                    "readme": {
                        "en": ""
                    }
                }
            }
        },
        "dmxoutCHOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "basic packet per sample",
                    "author": "",
                    "readme": {
                        "en": "This is the most basic usage of the DMX Out CHOP. In \"Packet Per Sample\" format, the DMX Out CHOP is expecting up to 512 single sample channels.\n\nIf you need to send non-consecutive DMX addresses, use something like a Constant (or Replace) CHOP to add spacer channels.  The names of the channels (especially names with numbers in them) have no effect on which DMX channels the data is sent out to. Only the channel index matters.\n\nMake sure to scale all of the input channels to 0 through 255, though you don't need to round those numbers to integers before they're sent.\n\nIn this example, two RGBAW lighting fixtures are patched to DMX Addresses 11 and 21, and it is being sent to the 4th Art-Net universe (AKA Universe 3 as Art-Net is base zero)"
                    }
                },
                "1": {
                    "title": "multiple DMX universes",
                    "author": "",
                    "readme": {
                        "en": "If you going to send multiple DMX universes from a single DMX Out CHOP,  you can only do so in \"Packet Per Channel\" format. Here, each channel is a universe and each sample is a DMX value.\n\nRemember you can only send up to 512 dmx values ranging between 0 and 255 per universe. The \"Net\", \"Subnet\" parameters are for older Art-Net implementations that split every 16 universes into 16 subnets and then 128 nets. These parameters do NOT refer to IP Addresses or Subnet Masks.\n\nNOTE: You don't have to increment the Net and Subnet parameters to get to higher universes numbers, just set the Universe parameter to any number and TD will split it into nets and subnets internally.\n\nBy default, the DMX Out CHOP comes with a routing table docked. In \"Packet Per Channel\" format, this allows you to specify which CHOP channel name gets sent to which DMX Universe number. You can send the same CHOP channel to multiple DMX universes in any order.\n\nIf you clear the \"Routing Table\" parameter, TouchDesigner will use the net, subnet and Universe parameters in the DMX Out's parameters to send the first universe of data and then every consecutive universe after that."
                    }
                },
                "2": {
                    "title": "LED tape pixel mapping",
                    "author": "",
                    "readme": {
                        "en": "Here is an example of an LED tape PixelMapping setup that uses SOPs to define where from the \"raster\" RGB values should be sampled from. The key to performant PixelMapping is controlling what does and does not cook.  In this case, none of the SOPs cook and there is only one TOPto CHOP.\n\nThere is also a rough preview system setup where a circle (representing a single LED) is being instanced using the positions of the LEDs obtained from the SOPTo CHOP and the color that is being send out to the LED controller."
                    }
                },
                "3": {
                    "title": "configuration",
                    "author": "",
                    "readme": {
                        "en": ""
                    }
                }
            }
        },
        "etherdreamCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "etherdream1",
                    "author": "",
                    "readme": {
                        "en": ""
                    }
                }
            }
        },
        "eventCHOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "manual events",
                    "author": "",
                    "readme": {
                        "en": "The Event CHOP can be a great tool to trigger overlapping events. In this example keep clicking button1 at different intervals to  create instances of a Tube SOP. The ADSR settings here will make the adsr channel simply rise once triggered and fallback to 0 once the Attack Level is reached."
                    }
                },
                "1": {
                    "title": "multiple types",
                    "author": "",
                    "readme": {
                        "en": "The Event CHOP also accepts multiple inputs. The index channel will return the value of the input that was just triggered. In this example you can create different textured instances of a cube. The adsr channel is used to lookup the y position and rotation of the cube over the events lifetime while the index channel is used to lookup the x position as well as the used texture."
                    }
                },
                "2": {
                    "title": "python trigger",
                    "author": "",
                    "readme": {
                        "en": "You can also trigger events in the Event CHOP using python. This is especially usefull as it lets you define the ADSR parameters per event. In this example we are giving each event a random speed.\n\nop('event3').createEvent(speed=randomSpeed)\n\nThe id channel is used to lookup a different color for each instanced geometry."
                    }
                },
                "3": {
                    "title": "event replicate",
                    "author": "",
                    "readme": {
                        "en": "One TOP is created per row.\n\nNote that the id that item1 renders for example, changes. Sometimes it doesn't matter, like when there is no info preserved in the replicants from the last frame it cooks.\n\nHere we stuff expressions into the parameters when the replicants are created. Because there is no row 1 sometimes, circle1 cannot have expressions that  refer to row 1.\n"
                    }
                }
            }
        },
        "expressionCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "threshold time",
                    "author": "",
                    "readme": {
                        "en": "This is a very useful network when working with inconsistent / noisy devices.  In  this case, if the button is down for the  length in seconds expressed in the speed1 Maximum parameter value, then the output goes on.\n\nThere are several ways to do this!"
                    }
                }
            }
        },
        "fanCHOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "quantized",
                    "author": "",
                    "readme": {
                        "en": "This example takes an LFO and fans out the value  into 8 channels.\n\nQuantization keeps the output values to strictly on and off."
                    }
                },
                "1": {
                    "title": "not quantized",
                    "author": "",
                    "readme": {
                        "en": "The same as the example above, without quantization. This means the channels blend from the current to the next smoothly."
                    }
                },
                "2": {
                    "title": "non timeslice",
                    "author": "",
                    "readme": {
                        "en": "You can also use a Fan CHOP on  non Timesliced  channels. "
                    }
                }
            }
        },
        "filterCHOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "filter",
                    "author": "",
                    "readme": {
                        "en": "The Filter CHOP most often is used to smooth out fast changes.\n\nType \"Box\" gives more linear smoothing."
                    }
                },
                "1": {
                    "title": "de spike",
                    "author": "",
                    "readme": {
                        "en": "This example shows a filter de-spiking an incoming pulse."
                    }
                },
                "2": {
                    "title": "types",
                    "author": "",
                    "readme": {
                        "en": "Here are a few examples of different filtering types. You can see their different attributes in the Trail CHOPs.\n\nNote the graphs are set to a minimum/max value of 0 to 1 or -1 to 1."
                    }
                },
                "3": {
                    "title": "filter per sample",
                    "author": "",
                    "readme": {
                        "en": "Filter each sample using the Filter per Sample parameter.\n\nThis turns Time Slicing off.\n\nThe Lag CHOP has the same feature."
                    }
                },
                "4": {
                    "title": "smooth when slow",
                    "author": "greg",
                    "readme": {
                        "en": "Filter each sample using the Filter per Sample parameter.\n\nThis turns Time Slicing off.\n\nThe Lag CHOP has the same feature."
                    }
                },
                "5": {
                    "title": "filter per chan",
                    "author": "greg",
                    "readme": {
                        "en": "Apply a different filter amount for each channel using expressions.\n\nOr you can put different filter times in a Constant CHOP.\n"
                    }
                }
            }
        },
        "gestureCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "autogesture",
                    "author": "",
                    "readme": {
                        "en": "Make any slider auto-gesture by putting the autoGesture component inside your slider (or beside it).\n\nIt works by pressing Shift before you click/drag/release on the Slider or Container COMP.\n\nAfter you release, it will repeat until the next time you click the slider without pressing Shift.\n\nFilter Time gives smoothing control.\n\nautoGesture1 was changed to work with Container COMPs - autoGesture1/panel is simply set to 'u v'.\n\nIt doesn't work with TUIK2 gadgets due to their way of storing the current value.\n\nYou can look inside autoGesture to see what it's doing.\n\nThis component may also be found in the Palette."
                    }
                },
                "1": {
                    "title": "gestureCapture",
                    "author": "",
                    "readme": {
                        "en": "Look in the Palette for gestureCapture in Techniques for a more complete system for capturing and maintaining multiple gestures, putting them into a set of keyframes, and outputting smoothed channels. Each gesture is any set of channels."
                    }
                }
            }
        },
        "holdCHOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "hold",
                    "author": "",
                    "readme": {
                        "en": "This example samples the value of input 1, whenever input 2 of the Hold CHOP is on."
                    }
                },
                "1": {
                    "title": "non timeslice",
                    "author": "",
                    "readme": {
                        "en": "This example features non Timesliced inputs, where the Hold CHOP samples input 1, whenever input 2 turns on."
                    }
                },
                "2": {
                    "title": "hold while on",
                    "author": "",
                    "readme": {
                        "en": "This example is different in that the Hold CHOP will continuously sample input 1 for as long as input 2 is On."
                    }
                },
                "3": {
                    "title": "hold timesliced while on",
                    "author": "",
                    "readme": {
                        "en": "same example but timesliced."
                    }
                },
                "4": {
                    "title": "hold winner",
                    "author": "",
                    "readme": {
                        "en": "This is the Family Feud technique, if you're familiar with American TV (for 3 families).\n\nc to clear. first one to hit the 1, 2 or 3 keys is the winner and nobody else can override.\n\nlogicOr - if any of the 3 keys are pressed, this goes on and timer1 starts, the running channel goes on, renamed winner.\n\nfanIn -> mathMult gives 1, 2 or 3 based on which key is pressed.\n\nwhen the running channel goes on, hold1 samples the input value, which is 1, 2 or 3 (it favors lower number if two or more are pressed at same time)\n\nPress \"c\" and the timer resets, making running be 0, making mathMult be 0.\n\ntimer1 is set to cycle (run) forever until it is initialized again.\n\nyou could detect ties by adding the 3 channels in merge1 and affecting mathAddOne to be 4 if sum is 2 or more. you need a new Constant TOP for that."
                    }
                }
            }
        },
        "infoCHOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "info of TOPs",
                    "author": "",
                    "readme": {
                        "en": "Many TOPs have useful information that can be accessed using an Info CHOP, such as index, resolutions, file lengths, and etc. "
                    }
                },
                "1": {
                    "title": "info of CHOPs",
                    "author": "",
                    "readme": {
                        "en": "Many CHOPs have useful information such as index fraction, file length in frames, audio sample rates, number of channels, and etc."
                    }
                },
                "2": {
                    "title": "info of SOPs",
                    "author": "",
                    "readme": {
                        "en": "You can get a lot of information about a SOP using the Info CHOP. You can get number and position of points, number of primitives, cook times, and etc."
                    }
                },
                "3": {
                    "title": "info of COMPs",
                    "author": "",
                    "readme": {
                        "en": "You can get information about many COMPs, such as useful information about a Window COMPs location, size, and whether it is open."
                    }
                }
            }
        },
        "joinCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "join end-to-end",
                    "author": "",
                    "readme": {
                        "en": "This joins CHOPs end-to-end.\n\njoin2 overlaps the two with a blend region.\n\njoin3 shows you can re-use inputs.\n\nJoin4 shows how you can specify inputs using the CHOPs paraqmeter.\n\njoin5 inserts a blend region with a cubic interpolation curve.\n\nAll the graphs are set to -1 to +1, with unit Samples on teh x-axis (via the RMB menu with Viewer Active on."
                    }
                }
            }
        },
        "lagCHOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "lag",
                    "author": "",
                    "readme": {
                        "en": "Equally lags value in both directions."
                    }
                },
                "1": {
                    "title": "lag up",
                    "author": "",
                    "readme": {
                        "en": "Much more lag applied on increasing values."
                    }
                },
                "2": {
                    "title": "overshoot",
                    "author": "",
                    "readme": {
                        "en": "Overshoots final value by 1 second."
                    }
                },
                "3": {
                    "title": "smoothing",
                    "author": "",
                    "readme": {
                        "en": "The Lag CHOP is useful for  smoothing out noise."
                    }
                },
                "4": {
                    "title": "timeslice",
                    "author": "",
                    "readme": {
                        "en": "Example of smoothing non-timesliced values."
                    }
                },
                "5": {
                    "title": "reset",
                    "author": "",
                    "readme": {
                        "en": "This shows how to  reset a lag, but using  it's reset value."
                    }
                },
                "6": {
                    "title": "steady rise and fall",
                    "author": "",
                    "readme": {
                        "en": "rises at a constant rate (.5 per second), and  falls at a different constant rate ( .25 per second) as per Lag's Slope  parameters.\n\nJust click anywhere on slider1 to set the target value.\n\nNOTE: The Trail CHOP is forced to display in the range 0 to 1: turn on Viewer Active, right-click -> Vertical Adapt -> 0 to 1"
                    }
                },
                "7": {
                    "title": "lag per sample",
                    "author": "",
                    "readme": {
                        "en": "Lag each sample using the Lag per Sample parameter.\n\nThe Filter CHOP has the same feature."
                    }
                }
            }
        },
        "laserCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "laser ideas",
                    "author": "",
                    "readme": {
                        "en": "a few ways to generate laser patterns."
                    }
                }
            }
        },
        "lfoCHOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "wave types",
                    "author": "",
                    "readme": {
                        "en": "The LFO CHOP can  produce many different wave types ranging from Sine waves to Pulses."
                    }
                },
                "1": {
                    "title": "patterns",
                    "author": "",
                    "readme": {
                        "en": "You can create multiple  channel of LFOs at once using patterns in the  Channel Name parameter."
                    }
                },
                "2": {
                    "title": "octave",
                    "author": "",
                    "readme": {
                        "en": "You can control the octave of an LFO using the first input of an LFO CHOP."
                    }
                },
                "3": {
                    "title": "phase",
                    "author": "",
                    "readme": {
                        "en": "You can purposely use phasing to create opposite wave forms."
                    }
                },
                "4": {
                    "title": "source",
                    "author": "",
                    "readme": {
                        "en": "You can optionally input your own source wave  into the LFO chops third input."
                    }
                }
            }
        },
        "limitCHOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "quantize",
                    "author": "",
                    "readme": {
                        "en": "In chopto2, if you imagine your camera is in the center, that is, math2 is your camera zx position, it will always see a field of data in front of it.\n\nlimit1 recycles the points.\n\nchopto1 is a semi-randomized field of points."
                    }
                },
                "1": {
                    "title": "clamp",
                    "author": "",
                    "readme": {
                        "en": "The Limit CHOP will always clamp the input between the assigned minimum and maximum values."
                    }
                },
                "2": {
                    "title": "loop",
                    "author": "",
                    "readme": {
                        "en": "This Limit CHOP will always loop between the maximum and minimum values, regardless of input value "
                    }
                },
                "3": {
                    "title": "zig zag",
                    "author": "",
                    "readme": {
                        "en": "When the Limit CHOP reaches it's maximum, it then descends to the minimum, before it ascends to the maximum again."
                    }
                },
                "4": {
                    "title": "positive",
                    "author": "",
                    "readme": {
                        "en": "This example limits the output to positive values only."
                    }
                },
                "5": {
                    "title": "normalize",
                    "author": "",
                    "readme": {
                        "en": "This example normalizes the output value between -1 to 1. "
                    }
                },
                "6": {
                    "title": "quantize1",
                    "author": "",
                    "readme": {
                        "en": "These examples quantize the incoming value.\n\nThe first quantizes to value steps of 1. The second quantizes to value steps of 0.5."
                    }
                },
                "7": {
                    "title": "infinite recycling",
                    "author": "",
                    "readme": {
                        "en": "This Limit CHOP will always loop between the maximum and minimum values, regardless of input value "
                    }
                }
            }
        },
        "logicCHOP": {
            "num_samples": 13,
            "examples": {
                "0": {
                    "title": "zero or less",
                    "author": "",
                    "readme": {
                        "en": "This example goes off when zero or less."
                    }
                },
                "1": {
                    "title": "invert",
                    "author": "",
                    "readme": {
                        "en": "This example inverts the  \"Off When Zero or Less\" so that it's On when zero  or less."
                    }
                },
                "2": {
                    "title": "bounds",
                    "author": "",
                    "readme": {
                        "en": "This example turns off when the value is outside the bounds -0.5 and 0.5"
                    }
                },
                "3": {
                    "title": "toggle",
                    "author": "",
                    "readme": {
                        "en": "This example takes 0 to 1 inputs pulses and creates a toggle value."
                    }
                },
                "4": {
                    "title": "pulse",
                    "author": "",
                    "readme": {
                        "en": "This example turns, and stays on, while the value is being changed."
                    }
                },
                "5": {
                    "title": "or",
                    "author": "",
                    "readme": {
                        "en": "This example will stay on if one OR the other incoming value is not 0."
                    }
                },
                "6": {
                    "title": "and",
                    "author": "",
                    "readme": {
                        "en": "Both input1  AND input2 have to be on for the Logic CHOP to turn on."
                    }
                },
                "7": {
                    "title": "timeslice 1",
                    "author": "",
                    "readme": {
                        "en": "This example shows the above functions performed on a non-Timesliced input."
                    }
                },
                "8": {
                    "title": "timeslice 2",
                    "author": "",
                    "readme": {
                        "en": "This example shows using OR and AND, similar to the above OR and AND examples, with non Timesliced input."
                    }
                },
                "9": {
                    "title": "make pulse",
                    "author": "",
                    "readme": {
                        "en": "a way to make a single-frame pulse:\n\nclick button_momentary"
                    }
                },
                "10": {
                    "title": "radio",
                    "author": "",
                    "readme": {
                        "en": "Example of how to make radio button functionality from regular momentary buttons. "
                    }
                },
                "11": {
                    "title": "index",
                    "author": "",
                    "readme": {
                        "en": "You can use Logic CHOP to find the range of inputs."
                    }
                },
                "12": {
                    "title": "timeslice on vs off",
                    "author": "",
                    "readme": {
                        "en": "Time Slice is default On (logic1, logic3, logic5). That means the start-end is at the current timeline frame.\n\nIt always causes the down-stream operators to cook. Middle-click on logic1, null1.\n\nTime Slice is turned off for logic2, logic4, logic6. The Null CHOPs are not cooking (dashed line is off) and their result remains the same as the input at Frame 1.\n\nTime Slice off has the same effect as having it on for the first 2 examples (press Button to see).\n\nBut logic5 and logic6 depend on the value of the previous frame (Channel Pre OP is set to Rising Edge), so Time Slice must be on for that to work properly (logic5).\n\nTurn Time SLice Off when appropriate."
                    }
                }
            }
        },
        "lookupCHOP": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "interpolation",
                    "author": "",
                    "readme": {
                        "en": "Interporlation avoids stepping that can occur between two values."
                    }
                },
                "1": {
                    "title": "exponential",
                    "author": "",
                    "readme": {
                        "en": "This gives fine control at the lower end of the slider.\n\nThe slider is allowed to go above its  0-1 range (you can set Clamp U High on) and because the Extend Right condition on the Wave CHOP is set to Slope, when  the slider goes above its 0-1 range, the lookup value goes up linearly above 10.\n\nThe Trail CHOP's viewer display is set to be fixed at the 0 to 10 range."
                    }
                },
                "2": {
                    "title": "lookup",
                    "author": "",
                    "readme": {
                        "en": "You can scrub through the Triangle wave using a 0-1 index."
                    }
                },
                "3": {
                    "title": "lookup1",
                    "author": "",
                    "readme": {
                        "en": "You can scrub through the Sine wave using a 0-1 index."
                    }
                },
                "4": {
                    "title": "multiple inputs",
                    "author": "",
                    "readme": {
                        "en": "A Lookup CHOP can perform its operation on multiple input indices, using multiple input lookup tables."
                    }
                },
                "5": {
                    "title": "lookup2",
                    "author": "",
                    "readme": {
                        "en": "A Lookup CHOP can also perform a lookup of 3 different indices across a single lookup table."
                    }
                },
                "6": {
                    "title": "color per midi note",
                    "author": "",
                    "readme": {
                        "en": "If your input is an on-off channel per key (like the Keyboard CHOP or MIDI In CHOP), then pressing a key can cause a lookup into a table to get the corresponding r, g, b values."
                    }
                }
            }
        },
        "mathCHOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "combine CHOPs",
                    "author": "",
                    "readme": {
                        "en": "Math can perform a variety of mathematical operations on multiple input CHOPs."
                    }
                },
                "1": {
                    "title": "combine channels",
                    "author": "",
                    "readme": {
                        "en": "Math can also be performed on multiple channels in a single CHOP."
                    }
                },
                "2": {
                    "title": "to and from range",
                    "author": "",
                    "readme": {
                        "en": "You can use the To and From Ranges to scale values, like a -1 to 1 sine wave LFO into a 0 to 10 sine wave."
                    }
                },
                "3": {
                    "title": "gate",
                    "author": "",
                    "readme": {
                        "en": "You can also use Math CHOPs to block values from reaching a certain destination by  multiplying them by the value of a button, which is 0 when off, and 1 when on. This means the value would remain 0 while the button is off, but the value would be passed unaffected if the button is on."
                    }
                },
                "4": {
                    "title": "invert",
                    "author": "",
                    "readme": {
                        "en": "It is helpful to\nbe able to invert\nbutton and slider ranges\nfrom 0 to 1, and instead\nmaking them from 1 to 0."
                    }
                },
                "5": {
                    "title": "length loop",
                    "author": "",
                    "readme": {
                        "en": "It is helpful to be able to invert button and slider ranges from 0 to 1, and instead make them from 1 to 0."
                    }
                },
                "6": {
                    "title": "math timeslicing",
                    "author": "",
                    "readme": {
                        "en": "A Math CHOP combining two a timesliced CHOP and a non-time-sliced CHOP tahes a slice of the non-timesliced CHOP and combines the two together."
                    }
                },
                "7": {
                    "title": "multi-ranges",
                    "author": "",
                    "readme": {
                        "en": "You can apply a different range to each of 3 channels using 3 Math CHOPs and the Scope parameter on the Common page, which applies the operation to only channels you select.\n\n\nScope is common on many CHOP filter operators."
                    }
                }
            }
        },
        "mergeCHOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "merge",
                    "author": "",
                    "readme": {
                        "en": "Merging multiple channels into 1 CHOP."
                    }
                },
                "1": {
                    "title": "unique",
                    "author": "",
                    "readme": {
                        "en": "If multiple channels of the same name are  merged, you can automatically give them unique names using the Duplicate Names options."
                    }
                },
                "2": {
                    "title": "keep first",
                    "author": "",
                    "readme": {
                        "en": "This allows you to keep only the first of the duplicate named channels being merged."
                    }
                },
                "3": {
                    "title": "different inputs",
                    "author": "",
                    "readme": {
                        "en": "You can merge inputs from a  variety of CHOPs."
                    }
                },
                "4": {
                    "title": "timeslice off",
                    "author": "",
                    "readme": {
                        "en": "You can merge non timesliced channels that have multiple samples. You can also merge non timesliced channels, then apply timeslicing to them."
                    }
                }
            }
        },
        "midiinmapCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "",
                    "readme": {
                        "en": "The MIDI In Map CHOP allows you to read  and map values from your MIDI device that is set up with the MIDI Mapper dialog.\n\nRaw MIDI can be accessed with the MIDI In CHOP.\n\nYou can access MIDI events with the  MIDI In DAT as well.\n\n Use the MIDI Device Mapper dialog (in Dialogs dropdown) to select your device. \n\nBe sure that the Device ID in the midiinmap CHOP matches the ID declared in the MIDI Device Mapper Dialog.\n\nAlso, make sure that your devices are plugged in before you open TouchDesigner."
                    }
                }
            }
        },
        "noiseCHOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "random",
                    "author": "",
                    "readme": {
                        "en": "This is random generated noise. "
                    }
                },
                "1": {
                    "title": "animated",
                    "author": "",
                    "readme": {
                        "en": "Animating the seed creates motion in the noise."
                    }
                },
                "2": {
                    "title": "timeslice",
                    "author": "",
                    "readme": {
                        "en": "Timesliced noise is useful if you're working with single sample signals."
                    }
                },
                "3": {
                    "title": "length",
                    "author": "",
                    "readme": {
                        "en": "You can specify the length of the noise channel. In this case the noise is 10 samples long."
                    }
                },
                "4": {
                    "title": "normalized",
                    "author": "",
                    "readme": {
                        "en": "This noise's values' have been normalized to lie with 1 and -1. "
                    }
                },
                "5": {
                    "title": "translate",
                    "author": "",
                    "readme": {
                        "en": "You can animate noise by animating the Translate X parameter."
                    }
                },
                "6": {
                    "title": "pattern",
                    "author": "",
                    "readme": {
                        "en": "You can create multiple channels simulatenously by using a pattern in the  Channel Name. "
                    }
                },
                "7": {
                    "title": "3d geo",
                    "author": "",
                    "readme": {
                        "en": "This contextual example demonstrates adding noise to the points in  an animated 3d geometry."
                    }
                }
            }
        },
        "nullCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "cook always",
                    "author": "",
                    "readme": {
                        "en": "By default, Null does nothing and takes no memory, but it can be used to force-cook nodes before it to make sure operatoes cook when TouchDesigner is in Perform Mode or the nodes are not being displayed.\n\nOSC will only output when lfo1 is 1. Without the Null CHOP forcing everything to cook, nothing will happen in Perform Mode."
                    }
                }
            }
        },
        "objectCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "get relative transforms",
                    "author": "",
                    "readme": {
                        "en": "For any 3D object (Target Object) you can get its transform relative to the world origin (by leaving Reference Object blank), or relative to another object (specify any Reference Object).  \n\nYou can get just position or rotation (and more), or with the Compute menu set to Transform. the full set of 9 transform channels: the position, rotation (euler angles) and scale. (You will need to specify the Transform Order, and the Rotation Order that you want.)\n\nThe Object CHOP takes into account all 3D object parenting hierarchies, and all manners of transforming the 3D Components, like the Bullet Solver COMP which transforms each moving object.\n\nThe Compute menu set to Distance will give the straight-line distance from the origin of one object to the origin of the other (or the world origin).\n\nThe Object CHOP ignores the SOPs (including Transform SOPs) inside the objects - they are irrelevant."
                    }
                }
            }
        },
        "oscinCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "osc",
                    "author": "",
                    "readme": {
                        "en": "These two examples both send and receive a sine wave over OSC.\n\nThe top one is sending the data out as Timeslice, while the bottom one is using samples.\n\nIn most cases you should use the \"Sample\" Format option in the OSC Out CHOPs as most other applications work with samples, and  not time slice."
                    }
                },
                "1": {
                    "title": "select channel",
                    "author": "",
                    "readme": {
                        "en": "This example shows how to select specific channels when using an OSC In CHOP to only retreive  the channels you need."
                    }
                }
            }
        },
        "panelCHOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "button",
                    "author": "",
                    "readme": {
                        "en": "Here we can get the panel values from a button, including click state, rollover u and v, as well as rollover state."
                    }
                },
                "1": {
                    "title": "slider",
                    "author": "",
                    "readme": {
                        "en": "Here we're monitoring the u and v, as well as which mouse button is  clicked over the panel.\n\nWe're also monitoring whether the ctrl, alt, or shift keys are pressed over the slider."
                    }
                },
                "2": {
                    "title": "field",
                    "author": "",
                    "readme": {
                        "en": "We can monitor whether a Field COMP is selected and in Focus."
                    }
                },
                "3": {
                    "title": "slider1",
                    "author": "",
                    "readme": {
                        "en": "This example is a demonstration of how Slider COMPs are made using Panel CHOPs. In this  example, all the parts of the slider are laid outside the panel so you can see them. "
                    }
                },
                "4": {
                    "title": "slider2",
                    "author": "",
                    "readme": {
                        "en": "Similar to the above slider example but also features rollover monitoring, and using the  Circle TOP."
                    }
                },
                "5": {
                    "title": "slider expressions",
                    "author": "",
                    "readme": {
                        "en": "and even simpler using expressions in the Circle TOP.\n\nThe insideu and insidev update even when not clicking the gadget, unlike rollu and rollv."
                    }
                }
            }
        },
        "parameterCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "parameter values into CHOP",
                    "author": "greg",
                    "readme": {
                        "en": "get parameter values into a CHOP.\n\nThis gets 3 specific channels among the Built-In parameters."
                    }
                },
                "1": {
                    "title": "evaluate all parameter types",
                    "author": "greg",
                    "readme": {
                        "en": "Get parameter values into a DAT where you can hold non-numeric data like from strings and paths parameters.\n\nWe use the Parameter CHOP par1, which is only used to get the channel names. We then convert it to a DAT where you can re-evaluate parameters including ones that are strings, paths, menus, etc in an Evaluate DAT.\n\nThis gets all channels that are the Built-In parameters."
                    }
                }
            }
        },
        "patternCHOP": {
            "num_samples": 9,
            "examples": {
                "0": {
                    "title": "range",
                    "author": "",
                    "readme": {
                        "en": "Use the Range page to set range to 0-10, where you can also quantize values to integers."
                    }
                },
                "1": {
                    "title": "taper",
                    "author": "",
                    "readme": {
                        "en": ""
                    }
                },
                "2": {
                    "title": "sop",
                    "author": "",
                    "readme": {
                        "en": "Convert from SOP points to CHOP samples, then feed that to Pattern that will create 3 random numbers for each sample, maintaining the same length as the incoming CHOP.\n\nConvert that back to a SOP and check the data with a SOP to DAT."
                    }
                },
                "3": {
                    "title": "add input",
                    "author": "",
                    "readme": {
                        "en": "One Pattern feeds another and they are added together via the Combine Channels parameter."
                    }
                },
                "4": {
                    "title": "decay curve",
                    "author": "",
                    "readme": {
                        "en": "Start with a Constant curve and taper it down."
                    }
                },
                "5": {
                    "title": "taper input",
                    "author": "",
                    "readme": {
                        "en": "Take an input CHOP and taper it up from the beginning by setting the Combine Channels parameter to Multiply."
                    }
                },
                "6": {
                    "title": "step per cycle",
                    "author": "",
                    "readme": {
                        "en": "Make 9 steps of 10 samples. In the Amplitude parameter, you need to multiply by .999 so that the last sample does not reach 10.  You make the Interger parameter Floor.  \n\nSee also the Limit CHOP to quantize."
                    }
                },
                "7": {
                    "title": "random number",
                    "author": "greg",
                    "readme": {
                        "en": "Pattern CHOP can generate multiple or single random numbers. The Seed parameter can be given any number to generate a random number between 0 and 1.\n\nThe seed can be driven by a slider, but a random number will recur when you go back to any value (which you may want sometimes).\n\nThe Clock CHOP's \"week\" channel expresses the time-of-month as a 0-1 value, and changes by a small amount every frame. pattern3 will repeat every week.\n\nYou can get a random number on-demand when a counter is incremented. mathRange offsets the seed numbers to asssure another counter doesn't generate the same sequence of random numbers. \n\nConnect lfo1 to count1 to get a random per-second.\n\npattern5/shuffle1 gives 10 random numbers at a time."
                    }
                },
                "8": {
                    "title": "random unique integer",
                    "author": "greg",
                    "readme": {
                        "en": "Say you have integers in a certain range, and you want to see all of them once, but in a random order.  This example gives the 77 numbers from 9 to 85 in random order. Furthermore, after you see them once, you will see them all again but in a different order. \n\nFirst it generates the linear sequence of desired numbers, then randomizes the order with the Sort CHOP.  Change the seed of Sort to change the order.\n\ntrim1 selects a differnt sample per frame.\n\ntimer1 causes Sort to re-randomize the order of the integers at the end of each 77 frame cycle.  It does this through the timer's callbacks, to prevent sort1 from cooking every frame.\n\n(You can also select cycles in timer1, pass it to a Null CHOP and set it to minimum cooks, and export that to sort1's seed parameter.)\n\nYou can slow it all down with the Timer CHOP's Speed parameter."
                    }
                }
            }
        },
        "performCHOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "fps vs milliseconds",
                    "author": "",
                    "readme": {
                        "en": "You can quickly access the FPS and frame cook  time of a project via the Perform CHOP. \n\nMilliseconds is a better measurement as it is not affected by the monitor refresh sync."
                    }
                },
                "1": {
                    "title": "memory stats",
                    "author": "",
                    "readme": {
                        "en": "You can also access useful GPU and CPU information, such as memory usage and active operators in a network."
                    }
                },
                "2": {
                    "title": "dropouts",
                    "author": "",
                    "readme": {
                        "en": "This example shows you if there are any frames skipped or dropped. 'cook' is 0 on frames that are skipped because the previous frame had not finished."
                    }
                },
                "3": {
                    "title": "hog",
                    "author": "",
                    "readme": {
                        "en": "Un-bypass the Hog CHOP (the arrow flag on the node). The performance will reduce. The Perform CHOP's \"cook\" channel indicates frames are dropped. \n\n Remember to bypass the Hog CHOP again, as it will cook every frame until it's bypassed."
                    }
                }
            }
        },
        "renameCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "rename patterns",
                    "author": "",
                    "readme": {
                        "en": "Alphabetic characters between [] get expanded one at a time.\n\nIf between [] is a number range, it's expanded to all numbers in that range."
                    }
                },
                "1": {
                    "title": "check select",
                    "author": "",
                    "readme": {
                        "en": "See the Select CHOP too."
                    }
                }
            }
        },
        "reorderCHOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "up and down",
                    "author": "",
                    "readme": {
                        "en": "These two examples reorder the incoming channels from lowest to highest, and then from highest to lowest."
                    }
                },
                "1": {
                    "title": "methods",
                    "author": "",
                    "readme": {
                        "en": "These are some examples of different reordering methods applied to multiple incoming RGB channels."
                    }
                },
                "2": {
                    "title": "2nd input",
                    "author": "",
                    "readme": {
                        "en": "This example puts the values of the first input, in the same order as the values of the 2nd input."
                    }
                }
            }
        },
        "resampleCHOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "double samples",
                    "author": "",
                    "readme": {
                        "en": "This example doubles  the amount of sample over the same time period. "
                    }
                },
                "1": {
                    "title": "triple time 25 samples per sec",
                    "author": "",
                    "readme": {
                        "en": "This example triples the length of the channe and samples it at 25 samples per second."
                    }
                },
                "2": {
                    "title": "quadruple time same shape",
                    "author": "",
                    "readme": {
                        "en": "This examples keeps the same sample rate, but quadruples the  length of the channel."
                    }
                }
            }
        },
        "scriptCHOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "script",
                    "author": "",
                    "readme": {
                        "en": "This example takes all the inputs of the script, creates 3 new outputs, and does some simple math operations on the inputs, and assigns new output values."
                    }
                },
                "1": {
                    "title": "values",
                    "author": "",
                    "readme": {
                        "en": "This example creates sine waves based on the 'me.time.frame' value entered on the Custom Parameter named Count. \n\nThe sine waves are all offset by the 2nd Custom Parameter named Offset.\n\n"
                    }
                },
                "2": {
                    "title": "script1",
                    "author": "",
                    "readme": {
                        "en": "This example scales all the channels by the value input in the Custom Parameter named 'Scale' on the 'Custom1' page of the Script CHOP.\n\nIt also deletes channel 'chan3', and creates a new channel named 'zzz'.\n\nThe graph range is -20 to +20 set via the graph right-click menu via Vertical Range..."
                    }
                },
                "3": {
                    "title": "new channels",
                    "author": "",
                    "readme": {
                        "en": "This example creates two new channels, with a variable number of samples that can be controlled using the 'Samples' custom parameter made on the  'Custom1' page of the Script CHOP."
                    }
                },
                "4": {
                    "title": "output samples above threshold",
                    "author": "",
                    "readme": {
                        "en": "Script CHOP threshold example where any samples that do not exceed value of a threshold (0.5) will be deleted. \n\nCreates long channel, interates through samples of the input, and shortens the result.\n\nvia barakooda"
                    }
                },
                "5": {
                    "title": "counter",
                    "author": "",
                    "readme": {
                        "en": "This example creates a very simple counter using custom parameters to control incrementing the value as well as resetting it.\n\nThe value in this example is held within the Operator's storage."
                    }
                }
            }
        },
        "scurveCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "soft limit",
                    "author": "",
                    "readme": {
                        "en": "If you have values coming in for a channel that are say between 2 and 5 (math1), and you want to limit them to be between 3 and 4, without hard-clamping them (as you would with a Limit CHOP). you would use an S Curve with a Lookup CHOP to soft-limit them to between 3 and 4.\n\nLookup's Input Range is set to 5. S Curve range is set to 3 to 4.  With this, the values at 3.5 don't change."
                    }
                },
                "1": {
                    "title": "soft limit",
                    "author": "",
                    "readme": {
                        "en": "S Curve with the Timer CHOP."
                    }
                }
            }
        },
        "selectCHOP": {
            "num_samples": 9,
            "examples": {
                "0": {
                    "title": "rename channels",
                    "author": "",
                    "readme": {
                        "en": "Select CHOPs are often used for simply renaming channels."
                    }
                },
                "1": {
                    "title": "pattern matching",
                    "author": "",
                    "readme": {
                        "en": "You can select channels using pattern chan* where * matches any text after \"chan\".\n\nSearch \"Pattern Matching\" in the wiki for the numerous ways of matching channel names with patterns."
                    }
                },
                "2": {
                    "title": "channels",
                    "author": "",
                    "readme": {
                        "en": "This picks out 2 specific channels and changing \"chan\" to \"d\" in their names."
                    }
                },
                "3": {
                    "title": "fetch by path",
                    "author": "",
                    "readme": {
                        "en": "These examples fetch 1 or more\nCHOPs using the CHOP path parameter."
                    }
                },
                "4": {
                    "title": "multiple channels",
                    "author": "",
                    "readme": {
                        "en": "You can pick out multiple specific channels by entering them one after another, separated by a space.\n\nNote the order is determined by the order you specify in Channel Names."
                    }
                },
                "5": {
                    "title": "swap",
                    "author": "",
                    "readme": {
                        "en": "This example fetches CHOPs constant1 and constant2 as they match the constant* path parameter.\n\nFrom these 2 CHOPs, the channels selected are in the range chan1 to chan8. \n\nThe last Select CHOP swaps what is before the ':' for what is after it."
                    }
                },
                "6": {
                    "title": "expand numbers",
                    "author": "",
                    "readme": {
                        "en": "expands a number range inside the []"
                    }
                },
                "7": {
                    "title": "expand alphabetic",
                    "author": "",
                    "readme": {
                        "en": "expands every alphabetic character inside the []"
                    }
                },
                "8": {
                    "title": "rename chop",
                    "author": "",
                    "readme": {
                        "en": "And see the Rename CHOP. It is a subset of the Select CHOP."
                    }
                }
            }
        },
        "shuffleCHOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "split or sequence",
                    "author": "",
                    "readme": {
                        "en": "Here are a few ways to manipulate channels and samples.\n\nSee the Fan CHOP too."
                    }
                },
                "1": {
                    "title": "split and filter",
                    "author": "",
                    "readme": {
                        "en": "This example takes each sample of a Noise CHOP and creates a channel with that value."
                    }
                },
                "2": {
                    "title": "channel names",
                    "author": "",
                    "readme": {
                        "en": "This example takes  all the scattered RGBA values from the TOP to CHOP and sequences them by name, so that you have a seperate R,G,B, and A, channel, for further processing.\n\nThe Movie File In TOP is down-resolutioned first."
                    }
                },
                "3": {
                    "title": "split 1",
                    "author": "",
                    "readme": {
                        "en": "This example takes every 10th sample from the original to form a new  channel. "
                    }
                },
                "4": {
                    "title": "split 2",
                    "author": "",
                    "readme": {
                        "en": "This example forms a new channel based every 9 samples of the  input value.\n\n You can follow the sine waves values, starting on chan0, going left to right, then continuing to chan1, going left to right, all  the way to chan9."
                    }
                }
            }
        },
        "slopeCHOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "slope",
                    "author": "",
                    "readme": {
                        "en": "These examples calculate the slope of the Speed CHOPs, whose slope we have set using a Constant CHOP.\n\nThey show that the rate you feed into the Speed CHOP can be extracted back using a Slope CHOP.\n\nIn math-talk, the derivative of the integral of a function is the function."
                    }
                },
                "1": {
                    "title": "acceleration",
                    "author": "",
                    "readme": {
                        "en": "Here we're calculating the acceleration rate of the incoming values.\n\nIt's not exact as there are round-off errors."
                    }
                },
                "2": {
                    "title": "rate of change",
                    "author": "",
                    "readme": {
                        "en": "Here we're calculating the acceleration rate of the incoming values."
                    }
                },
                "3": {
                    "title": "slope as change",
                    "author": "",
                    "readme": {
                        "en": "The Slope CHOP can be used to detect if a CHOP's value has changed. It is 0 when nothing has changed (from the  previous sample). Move the slider:\n\nThe Logic CHOP is set to output 1 when its input is non-zero, so all the slider's changes are detected.\n\nIn this case the LFO is  sampled whenever the slider moves.\n\nYou can also do this with scripting using the CHOP Execute DAT.\n\nTo Hold CHOP sampling is less jerky when the Filter CHOP is un-bypassed."
                    }
                }
            }
        },
        "soptoCHOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "SOP to",
                    "author": "",
                    "readme": {
                        "en": "In this example we're using the SOP to CHOP to access the point position of box1, then we're multiplying each point by noise, and using a CHOP to SOP to apply the new point positions."
                    }
                },
                "1": {
                    "title": "particle position",
                    "author": "",
                    "readme": {
                        "en": "In this example we're  able to access the position of every particle in the  particle system."
                    }
                },
                "2": {
                    "title": "point normals",
                    "author": "",
                    "readme": {
                        "en": "Here we've changed the direction of the normals of the circle that is being used as the particle source. This allows us to emit particles in different directions."
                    }
                }
            }
        },
        "sortCHOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "sample sorting types",
                    "author": "",
                    "readme": {
                        "en": "sort1 sorts the samples by lowest-to-highest value. Each channel is treated separately. So each channel has ascending values regardless of the other channels.\n\nsort2 uses the first channel (using Channel Indices parameter) to sort the samples of the three channels together: for example, chan1[31], chan2[31] and chan3[31] travel together.\n\nsort3 does the same with chan2, but sorting in decending order.\n\nsort4 does ascending, but chooses the channel by name \"chan3\".\n\nsort5 randomizes all the samples, but keeps the channels together. \n\nThen sort6 re-sorts by the first channel's ascending value, making it the same as the output of sort2."
                    }
                }
            }
        },
        "speedCHOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "seconds",
                    "author": "",
                    "readme": {
                        "en": "An example of how to count seconds using a Speed CHOP"
                    }
                },
                "1": {
                    "title": "index",
                    "author": "",
                    "readme": {
                        "en": "Speed CHOP is useful for driving Movie In TOP indices."
                    }
                },
                "2": {
                    "title": "zig zag",
                    "author": "",
                    "readme": {
                        "en": "Value zig zags between minimum and maximum values."
                    }
                },
                "3": {
                    "title": "loop",
                    "author": "",
                    "readme": {
                        "en": "Values loop from maximum back to minumum."
                    }
                },
                "4": {
                    "title": "speed to distance",
                    "author": "",
                    "readme": {
                        "en": "If pattern1 is the speed going into the Speed CHOP, then the output of speed1 is the time-history of the distance travelled."
                    }
                },
                "5": {
                    "title": "acceleration",
                    "author": "",
                    "readme": {
                        "en": "If you input an  acceleration value, your output will be  position, if you set the order type to  Second."
                    }
                },
                "6": {
                    "title": "speed bump",
                    "author": "",
                    "readme": {
                        "en": "Every button press bumps up the current value by a certain amount (1.2 as seen in the Panel Execute DAT), and it starts counting down from that value to 0 (the lower limit specified in the Minimum parameter of the speedBump).  \n\nIt prevents the upper value from exceeding a certain number (the Maximum parameter in speedBump).\n\nThe decay rate is specified in the constantSpeed CHOP (-0.5 means it goes down by .5 every second).\n\nThe Speed CHOP is reset with resetpulse.pulse() every time the button is pressed."
                    }
                },
                "7": {
                    "title": "push updown",
                    "author": "",
                    "readme": {
                        "en": "Pressing forces a rise at a given rate (Constant CHOP), and releasing forces a drop at another rate."
                    }
                }
            }
        },
        "spliceCHOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "splice insert",
                    "author": "",
                    "readme": {
                        "en": "This Splice CHOP inserts one CHOP into the other, preserving the original CHOP's samples."
                    }
                },
                "1": {
                    "title": "splice replace",
                    "author": "",
                    "readme": {
                        "en": "This Splice CHOP does a simple replace of one CHOP into the other."
                    }
                },
                "2": {
                    "title": "extract alter replace",
                    "author": "",
                    "readme": {
                        "en": "This extracts a part of a CHOP, alters it, then replaces the original samples.\n\nThe two Splice CHOPs have their \"start\" and \"trimlength\" parameters tied together with expressions.\n\n"
                    }
                },
                "3": {
                    "title": "pulse one sample",
                    "author": "",
                    "readme": {
                        "en": "If your Splice CHOP is used to instance geometry, adn each sample represents an instance's x y z and size, you would use this trick to grow the size whenever a different instance was chosen. \n\nChange the value of the Constant CHOP and look at spliceInstance.\n\nHere we use a Constant CHOP to represent the \"current\" sample (0 to 1 is mapped to 0 to 599), but you could use a Render Pick DAT to take a picked instance number and feed that down the chain.\n\nTHe Slope CHOP detects any change in its input, and the Math CHOP makes sure it's always positive. That's good to feed to teh Trigger CHOP. You can also use a CHOP Execute DAT to detect a change and trigger the Trigger CHOP's Reset Pulse parameter.\n\n"
                    }
                }
            }
        },
        "stretchCHOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "reverse samples",
                    "author": "",
                    "readme": {
                        "en": "reverses the order of samples and keeps the same length of CHOP (10 seconds)."
                    }
                },
                "1": {
                    "title": "half length",
                    "author": "",
                    "readme": {
                        "en": "half th number of samples (300), half the  length (5 seconds)."
                    }
                },
                "2": {
                    "title": "times 10 and shift",
                    "author": "",
                    "readme": {
                        "en": "ten times longer, but also makes the CHOP start at 1 second (frame 31).\n\nSee the popup help to see the range.\n\nThe second example has each sample repeated 10 times as you see when you zoom in on the graph."
                    }
                }
            }
        },
        "switchCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "switch",
                    "author": "",
                    "readme": {
                        "en": "Use the radio to switch between the different inputs."
                    }
                },
                "1": {
                    "title": "switch input",
                    "author": "",
                    "readme": {
                        "en": "This example is the same as the above example except that the index selection is passed as the first input."
                    }
                }
            }
        },
        "timerCHOP": {
            "num_samples": 24,
            "examples": {
                "0": {
                    "title": "why timer",
                    "author": "",
                    "readme": {
                        "en": "The Timer CHOP was created because this was too hard:\n\nRing a bell after 5 seconds.\n\n... too many OPs, too many parameters, click Reset on the Speed CHOP... too much thinking to get right."
                    }
                },
                "1": {
                    "title": "basic timer",
                    "author": "",
                    "readme": {
                        "en": "This is the basic timer with Length that you can set to any number of seconds.\n\nClick Initialize to get ready, then Start to  begin counting.\n\nOr just press Start at any time to initialize and begin counting right away.\n\nYou can set Length to seconds, frames or samples using the menu on the right of Length. "
                    }
                },
                "2": {
                    "title": "output channels",
                    "author": "",
                    "readme": {
                        "en": "This is the same timer but you can get out more channels via the Outputs page:\n\nSeconds (in the Timer Count menu) Ready (means the timer has been initialized) Running (It's been started) Done Pulse (another form of Done)\n\nOn the Timer page, you can click Go to Done at any time.\n\nStart and watch trail2 a few times to see how the channels relate to each other.\n\nconstant_timerFrame shows you can also get some values from the Timer CHOP python members."
                    }
                },
                "3": {
                    "title": "delay, cycle, done",
                    "author": "",
                    "readme": {
                        "en": "Delay will cause some seconds of delay after the Start and before the timer starts counting up.\n\nTimer can also cycle: Click Start and watch a few times. It will cycle 4 times.\n\nYou can interrupt and make it cycle fewer times:  Click parameter Exit at End of Cycle, or Go to Done to exit cycling immediately.\n\nCycle controls: Cycle on/off, Cycle Limit (infinite when off), Maximum Cycles (when Cycle Limit is on).\n\nThe cycles_pulse channel triggers the depth-finder sound.\n\nThe done_pulse channel triggers the \"done\" text in Text TOP.\n\n( Expert NOTE: To make sure the cycle_pulse and done_pulse channels are always exported correctly, the  Export Method on the Common page is set to DAT Table by Name. This is true of the Timer CHOP and other CHOPs with selectable channels and specific names, like Beat and Perform. )\n\nThe parameters Speed and Play vary the timer speed."
                    }
                },
                "4": {
                    "title": "segments - serial",
                    "author": "",
                    "readme": {
                        "en": "Segments can be like back-to-back timers in one Timer CHOP. We call back-to-back timers \"Serial Timers\".\n\nMake a table with columns named like the parameter internal names: length, delay, cycle, ..., and put in some values for length or delay, etc.\n\nThe units of length, delay etc is determnied by the Segment Units menu, the default is seconds.\n\nA segment is one timer per row, the first segment is numbered 0, starting at row 1 of the table.\n\nThey replace the parameters temporarily.\n\nClick Start and watch a few times.\n\nIf you go to the Segments page, you can press Previous Segment or Next Segment etc to jump ahead or back in time.\n\n\n\n "
                    }
                },
                "5": {
                    "title": "segments begin",
                    "author": "",
                    "readme": {
                        "en": "Alternately you can specify the begin time of each timer, as you would with a bunch of video clips on a timeline.\n\nReplace the Timer CHOP's Segments DAT parameter with table_begin4.\n\nNote that you have to be careful if overlapping the segments. If they do overlap, the later segments take precedence.\n\nThe segments do not have to be in order - they are pre-sorted, as in table_begin_anyorder4.\n\n\n\n\n\n"
                    }
                },
                "6": {
                    "title": "segment interpolate",
                    "author": "",
                    "readme": {
                        "en": "With Serial Timers, you can generate a curve that interpolates from the current value to the new values over the segment time Length.\n\nThe column \"v1\" is not mapped to a parameter. It is output from the Timer CHOP as a channel. To do this, on the Segments page, in the parameter Columns to Custom Channels, you put the names of the columns to output as channels, in this case \"v1\".\n\n By default v1 will step to its new value at the start of a segment.\n\nTo make it interpolate, select from the  Custom Channel Interpolation menu, for example, Linear to Value.\n\nWith a 0-length first segment, its v1 determines the \"initial value\" of v1.\n\n\n\n\n\n "
                    }
                },
                "7": {
                    "title": "interpolate external",
                    "author": "",
                    "readme": {
                        "en": "Advanvced technique:\n\nIf each channel needs to interpolate differently, say one is linear, one is ease in/out, you  need to interpolate outside the Timer CHOP. A method is shown here.\n\nYou put the names of the columns to output as channels, in this case \"v1\" and also \"length\".\n\nv1 and length are passed to a Filter CHOP to do the interpolation, length is used as the  Filter Width.\n\nClick Initialize and Start and watch the length and V1 channels step according to the rows in the table.\n\nThe Filter Width parameter is the \"length\" that it retrieves from the table.\n\nWhen you change the Filter CHOP's Type menu to Gaussian, the filters act as an ease-in ease-out.\n\nThe filters are reset when you Initialize or Start: The \"ready\" channel is exported to their Reset Pulse parameters.\n\n\n\n\n\n"
                    }
                },
                "8": {
                    "title": "segments parallel",
                    "author": "",
                    "readme": {
                        "en": "The same tables can be used to run the timers in parallel. On the Segments page, set the Segment Method to Parallel Timers, then press Initialize, then Start.\n\nNote there is one channel per segment for each channel type selected on the Output page.\n\nTry this Timer CHOP with tableBeginAnyorder.\n\n\n\n "
                    }
                },
                "9": {
                    "title": "text per segment",
                    "author": "",
                    "readme": {
                        "en": "You can feed text into an Info DAT for each segment of the timer. \n\nYou can create a column of any name in the segments table, \"message\" in this case, and add text in each rows. Then you put that column name in the parameter Columns to Info DAT on the Segments page.\n\nThat will cause a row in the Info DAT, \"message\" to contain the text of the segment as it plays.\n\nClick Start and watch the Info DAT.\n\n\n\n "
                    }
                },
                "10": {
                    "title": "callbacks",
                    "author": "",
                    "readme": {
                        "en": "\"Callbacks\" are located in the docked node, timer8_callbacks.\n\nCallbacks are functions that are called when timer events occur. They can be used to set parameters and trigger events, run scripts and many other things.\n\nIn this example it prints the current time, \"running seconds\" when it initializes, when it is ready, starts, on segment and, cycles and on done.\n\nOpen up the textport (Dialogs -> Tetport), press Start and watch the output of the callbacks.\n\nLook at the DAT that's docked to the Timer CHOP.\n\nwhileTimerActive() is especially noteworthy as it is called every frame that a segment's timer is counting, and not at any other time."
                    }
                },
                "11": {
                    "title": "long initializations",
                    "author": "",
                    "readme": {
                        "en": "When you Initialize, you can initiate actions and check conditions to assure the initialization is ready, and if not ready, have onInitialize() called some number of frames later.\n\nIn this case, when the Stalling button is on, when you press Initialize or Start, the onInitialiize() callback checks if the Stall button is on, and if so, it returns 50, which is the number of frames to wait until it calls onInitialize() again. When it returns 0, it proceeds to the ready state, and then starts the timer if the user has pressed Start.\n\nIf Stalling is on and then you press Start, it will wait until Stalling is off and then start counting right away.\n\nThis is useful for preparing movies, loading files, waiting for servers to respond or other things that will keep the timer from being ready.\n\n\n\n "
                    }
                },
                "12": {
                    "title": "cycle end alert",
                    "author": "",
                    "readme": {
                        "en": "Before a segment ends, you can have the Timer CHOP call onCycleEndAlert().\n\nIn timer10, the Cycle End Alert time is set to 2 seconds, so onCycleEndAlert() gets called 2 seconds before timer10 finishes.\n\nonCycleEndAlert() plays an audio cue, and  initiates timer10_next to start.\n\nHowever the onInitialize() in timer10_next return 10 until timer10's \"running\" channel goes to 0 and the depthfinder audio sample finishes playing. \n\nSo every 10 frames, onInitialize() is called and stays in its \"initializing\" state until the audio finishes and timer10 is done."
                    }
                },
                "13": {
                    "title": "channel history",
                    "author": "",
                    "readme": {
                        "en": "This is set up to capture a clean start-to-end set of channels in the Trail CHOP.\n\nWhen the timer initializes, the onInitialize() callback resets and starts the Trail CHOP, then when onDone() is called, it turns the Active parameter Off on the Trail CHOP after another 10 frames.\n\nOn some segments, the cycleendalert column of table14 causes the onCycleEndAlert() callback to be called some number of seconds before the  segment is over, supposedly to prepare for  the next segment.\n\ninitialize14 and start14 show you can drive the initialization and starting with the two inputs. "
                    }
                },
                "14": {
                    "title": "time scrubber go to",
                    "author": "",
                    "readme": {
                        "en": "The goto_scrubber slider will cause the Timer CHOP to jump to a specific time or frame in the sequence.  The slider 0-1 range is re-ranged in the Math CHOP to be 0 to 25.\n\ngoTo(frame = 601): goes to frame 601, where frame 1 is the first frame. \n\ngoTo(segment = 3, cycle = 2, seconds = 1):  Jumps to segment 3, cycle 2, and will set time to 1 second.\n\ngoTo(seconds = 35):  If cycle is off, and segment 1 = 10, segment 2 = 15,  segment 3 = 20, this will jump to segment 3, with time set  to 10 seconds.\n\ngoTo(seconds = 35):  If cycle is on for segment 2 (max cycles = 10), and  segment 1 = 10, segment 2 = 15, this will jump to segment 2,  cycle = 1 (as in: one cycle has completed),  and with time set to 10 seconds.\n\nYou can set the global timecode directly with the script  in set_timecode14. You can also get the global timecode with the expression in text_timecode14. "
                    }
                },
                "15": {
                    "title": "timers overlapping",
                    "author": "",
                    "readme": {
                        "en": "This takes a list of segments that overlap - at most two segments at a time.\n\nClick/scrub and release the slider to see it operating. Or click above the slider to play it from the start.\n\nEach segment has a rise time and fall time that fade-on and -off the lines of text. This accomplished with the Trigger CHOP exported to the Text TOP.\n\nIt splits the segments into two groups,  the even segments and the odd segments appearing, as two rows of red text strings. Each group goes to one Timer CHOP.\n\nClicking on the slider or above it will scrub or play the timers by calling the goTo() method on each Timer CHOP. That's in the Panel Execute DAT.\n\nIt renders one Text TOP for each Timer CHOP and adds the images together.\n\nIn the interface you can change the red bars' start time, end time, and you can shift the bar: click/drag the  left, middle and right part of any bar. That changes the table_haiku."
                    }
                },
                "16": {
                    "title": "state machine game",
                    "author": "",
                    "readme": {
                        "en": "Timer CHOPs can trigger each other and implement state machine behavior.\n\nMost Timer CHOPs here initiate some action in another Timer CHOP using:\n\n(1) its \"ready_pulse\" channel is exported to the Initialize parameter on another Timer CHOP.\n\n(2a) its \"done\" channel is exported to a Start parameter on another Timer CHOP, \n\nor\n\n(2b) some of its callbacks running a python command to .pulse() another Timer CHOP. You would see this in onDone()  sometimes.\n\nNormally you pulse the Initialize parameter of a bunch of Timer CHOPs, then Start one Timer CHOP, The behavior continues forever or until one Timer stops awaiting further action from the user."
                    }
                },
                "17": {
                    "title": "start hold loop end",
                    "author": "",
                    "readme": {
                        "en": "Timer CHOPs can implment an animation technique called Start-Holdloop-End - SHE.\n\nThere are three animations that fit together seamlessly, and where the second is a loop that can run perpetually.\n\nAn \"Exit at End of Cycle\" signal is received while the second loop is running so that the second animation finishes its loop and then continues on to run the third loop.\n\nThe Switch TOP is set to 0 1 or 2 by the three Timer CHOPs by their onStart() and onInitialize() callbacks.\n\nComplete has no effect until the middle timer is running."
                    }
                },
                "18": {
                    "title": "sequence animation",
                    "author": "",
                    "readme": {
                        "en": "Each timer can drive an Animation component that drives a 3D object.\n\nIn this case, the times are expressed in frames in the Timer CHOP, and frame (relative to 0) is sent to the Animation Component.\n\nThe latter is set to be driven by frame number,  starting from 1. \n\nThe duration in the Timer table needs to match the duration of the keyframes in the Animation  component.\n\nNot complete: eval15 automatically fetches the lengths from the Animation components.\n\n\nALTERNATE:\n\nIf you want to control the speed that the animations play back at via the segments DAT, you can put the desired lengths in seconds or frames in the segments table, then use the 0-1 timer_fraction channels in the Animation Components by setting their Input Index Units parameter to Fraction, and alter the Select CHOP in the Animation component to use  timer_fraction*."
                    }
                },
                "19": {
                    "title": "jump to segment",
                    "author": "",
                    "readme": {
                        "en": "The buttons cause the Timer CHOP to jump to different segments after the current segment completes, thanks to the endofcycle=True in goTo().\n\nEven after it reaches Done, you can jump to any segment and keep counting.\n\nThe running_seconds increases when you jump to any segment. The cumulative_seconds jumps to whatever would be if you had initialized and then reached that segment naturally.\n\nIf you want to reset to 0, you need to press Initialize and then you can jump anywhere."
                    }
                },
                "20": {
                    "title": "timer back-to-back",
                    "author": "",
                    "readme": {
                        "en": "This runs a schedule of segments that are back-to-back, do not overlap, and each segment has a variable length.\n\nYou can click the right of a segment and  lengthen or shorten the segment."
                    }
                },
                "21": {
                    "title": "movie sequencer",
                    "author": "",
                    "readme": {
                        "en": "This takes a list of movies and generates a timed playlist where each movie crossfades to the next over N seconds, default 1 second (in crosstime DAT).\n\nSet the Folder DAT Root Folder to a location where movies exist on your computer.\n\nClick/scrub and release the slider to see it operating. Or click above the slider to play it from the start.\n\nEach movie crossfades via a Trigger CHOP curve that fades out/in the movies before adding them together.\n\nIt splits the movies into two groups,  the even movies and the odd movies appearing, as two rows of red text strings. Each group goes to one Timer CHOP.\n\nClicking on the slider or above it will scrub or play the timers by calling the goTo() method on each Timer CHOP. That's in the Panel Execute DAT.\n\nIt renders one Text TOP for each Timer CHOP and adds the images together.\n\n "
                    }
                },
                "22": {
                    "title": "sequence channels",
                    "author": "",
                    "readme": {
                        "en": "This takes a set of animation clips that can be sequenced end-to-end, with the second clip optionally looping.\n\nIt can be one animation that is cut into three or more parts.\n\nThis example doesn't do blending.\n\nThe \"chop\" column sets which CHOP to select from, and its Lookup CHOP gets its index from the \"timer_fraction\" channel.\n\nClick \"End Segment at End of Cycle\" while it's looping to cleanly go to the next segment.\n\n"
                    }
                },
                "23": {
                    "title": "run delayed + check",
                    "author": "",
                    "readme": {
                        "en": "When clicking Start, this waits a frame (Delay parameter = 1 frame), runs a command, then optionally checks on subsequent frames for a desired condition.\n\nThis is an alternative to running the run(cmd, 'delayFrames=1) and writing a python script to loop one or more frames to wait until a condition is satisfied.\n\nIt is set to time out after 10 frames with the Cycle parameters."
                    }
                }
            }
        },
        "timesliceCHOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "analysis",
                    "author": "",
                    "readme": {
                        "en": "Move the slider and see the Trail CHOP.\n\nNow un-bypass the Hog CHOP above. Now TouchDesigener is skipping most frames.\n\nWhen you move the slider, the slider values are stepping too, as you see with channel v1 in the Trail CHOP.\n\nBut the Time Slice CHOP figures out the in-between values and passes all those samples to its output.\n\nThe third channel shows which frames were cooked (1) and which frames were mossed (0).\n\nSee also:\n\nthe wiki page \"Time Slicing\".\n\nthe training video \"Time Slicing Vid\" "
                    }
                },
                "1": {
                    "title": "interpolations",
                    "author": "",
                    "readme": {
                        "en": "With the Hog CHOP un-bypassed, TouchDesigener is skipping most frames.\n\nThis shows the three ways the Time Slice  CHOP deals with its input, which is a 2-second smooth-noise and Extend Conditions set to mirror outside its 2-second range. \n\nEach time the Time Slice CHOP cooks, it samples one value of the input CHOP  and holds that value for the entire CHOP.\n\nIn teh second case, it linearly interpolates from one frame to the next.\n\nIn the third case, it extracts multi-samples from the input. "
                    }
                },
                "2": {
                    "title": "single sample to time slice",
                    "author": "",
                    "readme": {
                        "en": "The first 2 CHOPs simulates a case where you get only one new sample every time a CHOP cooks, or an input device is read. An example is getting data from a Kinect or a Leap Motion device, you are taking camera input into CHOPs via a TOP to CHOP.\n\nWithout a Time Slice CHOP set to Linear the values step from one time slice to the next. The Time SLice CHOP can smooth that.\n\nThe Filter CHOP smooths it a bit further,  though making it a bit mose sluggish. "
                    }
                }
            }
        },
        "toptoCHOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "single pixel",
                    "author": "",
                    "readme": {
                        "en": "You can get the  RGBA values o a single pixel."
                    }
                },
                "1": {
                    "title": "column",
                    "author": "",
                    "readme": {
                        "en": "Here we have the RGBA values of a whole column of the image."
                    }
                },
                "2": {
                    "title": "row",
                    "author": "",
                    "readme": {
                        "en": "Here we have  the RGBA values of a full row of the image."
                    }
                },
                "3": {
                    "title": "colorpicker",
                    "author": "",
                    "readme": {
                        "en": "This is a basic example of how you could make your own color picker, using the u and v of a Panel CHOP as co-ordinates to analyze."
                    }
                }
            }
        },
        "trailCHOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "trail types",
                    "author": "",
                    "readme": {
                        "en": "These examples show the different lengths of trails for the same input "
                    }
                },
                "1": {
                    "title": "trail range",
                    "author": "",
                    "readme": {
                        "en": "The Trail CHOP trail1 is forced to display in  the range 0 to 1: turn on its Viewer Active, right-click -> Vertical Adapt -> 0 to 1 or one of the other ranges, or make your own range."
                    }
                },
                "2": {
                    "title": "trail dots",
                    "author": "",
                    "readme": {
                        "en": "The Trail CHOP displays a dot at each sample. You need to stretch  the CHOP tile or reduce the range  of the Trail before the dots appear sine htey are normally too close to  eadh other.\n\nturn on its Viewer Active, then right-click -> Dots"
                    }
                },
                "3": {
                    "title": "trail multigraph",
                    "author": "",
                    "readme": {
                        "en": "The Trail CHOP is set to display multiple graphs: turn on its Viewer Active, right-click -> Graph Per Single Channel and set Number of Graphs.\n\nWhen channels have very different ranges, it is better to display them in separate graphs."
                    }
                },
                "4": {
                    "title": "trail while operating slider",
                    "author": "",
                    "readme": {
                        "en": "Sometimes you may want to  capture something in a Trail CHOP and freeze it to examine or use later.\n\nThis activates the Trail CHOP only while a slider is active. The \"select\" channel goes on while you are clicking on a slider.\n\n(try the rollover panel value in  the Panel CHOP as an alternative.)\n\nYou can also clear out the Trail channels by exporting the Panel CHOP to the Reset Pulse button on the Trail CHOP."
                    }
                }
            }
        },
        "transformCHOP": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "transform to geo",
                    "author": "",
                    "readme": {
                        "en": "The Transform CHOP has translate/rotate/scale parameters like all 3D objects, but it outputs a set of channels that can be passed to any of the 3D objects. (this form to-be-implemented shortly)\n\nBy default it outputs the transform as tx ty tx and scale, plus \"euler angles\" rx ry rz which is a way of representation rotations.\n\ntransform2 has the output set to 16 channels that represent the 4x4 matrix describing the same transform, which can be fed to geo2.\n\nOn the Geometry COMP's Pre-Xform page you need to turn on Apply Pre-Transform, then put the path of the CHOP containing the transform into the parameter Xform /CHOP/DAT.\n\ngeo3 shows it getting from a DAT whose cells are the same as transform2's channels arranged in columns.\n\ntransform3 outputs the transform as an XYZ position plus a 4-channel quaternion, along with scale and the xord transform order channel.\n\n"
                    }
                },
                "1": {
                    "title": "transform order",
                    "author": "",
                    "readme": {
                        "en": "In transform2, the translate and rotate channels that are output depend on what is called \"transform order\" and \"rotate order\". \n\nThat is, the tx ty tz rz ry rz sx sy sz numbers depend on if you apply them in the order translates, then rotates, then scales, if you do the rotates in the order rotate around the X axis, then Y axis then the Z axis.\n\nThe order that is assumed is determined by the xord and rord channels. 0 0 is the default, and the integers in these channels is the index of the selected menu item in the Transform Order parameter and the Rotate Order parameter.\n\ntransform4 has different Transform Order and Rotate Order than transform2 on their Output pages. When you change those menus to anything else, they apply the same transform on the objects, as you see in geo1 and geo2.\n\nThis is evident when you convert the output to a 4x4 matrix: The 4x4 matrix (transform3_4x4 and transform5_4x4) remains the same when you change transform2 and transform4's transform orders.\n\n"
                    }
                },
                "2": {
                    "title": "inverse matrix",
                    "author": "",
                    "readme": {
                        "en": "The \"inverse\" of a transform does the opposite of a transform. If a transform takes an object from the origin to a new postion/rotation/scale, then the inverse of that transform will take an object at that new position/rotation/scale back to the origin with no rotation/scale.\n\nSo if you multiply a transform by its inverse, you will get back the default \"identity\" matrix.\n\n"
                    }
                },
                "3": {
                    "title": "transform input",
                    "author": "",
                    "readme": {
                        "en": "THis takes a transform and applies a further transform to it.\n\ntransform1 scales by .7, then rotates in Z by 45 degrees, then moves in X by 3.\n\ntransform2 and transform4 both move in Y by 3, but they differ in their Multiply Order parameter. \n\ntransform2, whose Multiply Order is set to \"Input, then Transform Page\" does the input's transform first, then applies the transform of the Transform Page.\n\ntransform4, set to \"Transform Page, then Input\" does the transform of the Transform Page, then the input transform from tranform1.\n\n\nHow you get the 3D background grids is by making Viewer Active, right-clicking on the viewer, selecting Display Options, and choosing the middle grid on the bottom, giving an XY grid.\n\n\nSide note for your education: https://www.enviral-design.com/matrices-are-hard/\n\n"
                    }
                },
                "4": {
                    "title": "multiple channel sets",
                    "author": "",
                    "readme": {
                        "en": "Two 4x4 transforms in rename1 and rename2 are merged as 32 channels named left* and right*, and then transformed again as two 180 rotations, and displaying in geo3 and geo4.\n\nIn transform3, each set of legal channel suffixes (m00, m01...) that have a unique prefix (left, right) are treated as separate transforms that get affected separately.\n\nselect1 and select2 pull them apart for display. \n\nThen join3 combines them another way: as a 2-sample CHOP with 16 channels. Again these can be transformed as 2 sets of transforms.\n\nIn this case the resulting 2-sample CHOP is used to instance two toruses on geo5.\n\n\n\n"
                    }
                },
                "5": {
                    "title": "multiple channel sets better",
                    "author": "",
                    "readme": {
                        "en": "3 transforms are in set1 to set3.\n\nThe Join CHOP puts them together as 3 samples of 16 transform channels.\n\ntransform1 does a 180 degree rotation on all 3 of them, and outputs them in translate/rotate/scale format.\n\ngeo1 instances them.\n\nselect_sets merges them using set* pattern matching of node names (could have used set[1-3]).\n\ntransform2 also does the 180 rotation on all sets.\n\nselect_set1 to select_set3 pulls them apart using pattern matching: see the expression in the Channel Names parameter.\n\ng1 to g3 are copies of each other - see their expression in the parameter Xform Matrix/CHOP/DAT."
                    }
                },
                "6": {
                    "title": "quaternion rotation",
                    "author": "",
                    "readme": {
                        "en": "work-in-progress pending transform interpolation feature.\n\n\n"
                    }
                }
            }
        },
        "triggerCHOP": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "",
                    "readme": {
                        "en": "basic triggering setup"
                    }
                },
                "1": {
                    "title": "extend pulse",
                    "author": "",
                    "readme": {
                        "en": "You can use Trigger to extend the length of time a channel stays on.\n\nYou usually don't need logic1 because CHOPs are \"on\" while the value is above zero.\n\nYou can follow it with a CHOP Execute DAT taht triggers when onToOff."
                    }
                },
                "2": {
                    "title": "delay and fixed length",
                    "author": "",
                    "readme": {
                        "en": "You can delay a starting pulse, and then make sure the trigger stays on an exact number of seconds, no matter how long the input stays on.\n\nYou adjust the Delay Length parameter and the Peak Length parameter.\n"
                    }
                },
                "3": {
                    "title": "trigger after a time threshold",
                    "author": "",
                    "readme": {
                        "en": "For triggering with jittery inputs.\n\nThis will trigger only if the noise1 CHOP has been on for .3 seconds or longer.\n\n\"On\" in CHOPs means a value that is greater than 0.\n\nTwo ways are illustrated: noise1 + count1 + trigger1 (preferred).\n \nAnd noise1 + logic1 + speed1 + trigger2.\n\nnoise1 is varying around 0. The Count CHOP is set to 0 when its input is 0 or less. When it's above 1, it is counting time (While On parameter).\n\nThe Trigger CHOP's Trigger Threshold parameter is is set to .3. The trigger happens when the Count CHOP reaches .3 (seconds).\n\nLogic/Speed operate similarly. When logic1 == 1. speed1 counts seconds."
                    }
                },
                "4": {
                    "title": "when mostly on",
                    "author": "",
                    "readme": {
                        "en": "For triggering with jittery inputs:\n\nThis will trigger if the input has been on more often than it's been off.\n\nSpeed is counting seconds, and Trigger's Threshold is is set to .3."
                    }
                },
                "5": {
                    "title": "complete waveform",
                    "author": "",
                    "readme": {
                        "en": "You can get a complete waveform by turning off the Time Slice parameter.\n\nOne form is a controllable linear rise time, hold time, fall time.\n\nFor more elaborate shapes you can use the Keyframe CHOP inside an Animation Component."
                    }
                },
                "6": {
                    "title": "other triggers",
                    "author": "",
                    "readme": {
                        "en": "other forms of triggering without the Trigger CHOP"
                    }
                }
            }
        },
        "trimCHOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "trim1",
                    "author": "",
                    "readme": {
                        "en": "Trim a 10-second CHOP down to 3 seconds (600 frames down to 120, and 600 samples down to 120). \n\nThe graphs have been set to  display sample number on X.\n\nThe result starts at sample index 120 (frame 121).\n\nThe Shift CHOP shifts it to sample index 0."
                    }
                },
                "1": {
                    "title": "trim2",
                    "author": "",
                    "readme": {
                        "en": "Take a time-sliced CHOP which  would be 1 or more frames, and trim it to be one frame long, the most recent frame.\n\nTo see this, make the Hog CHOP Active.\n\nBy trimming like this, the CHOP becomes non-time-sliced, which you can see by middle-clicking on the operators."
                    }
                }
            }
        },
        "waveCHOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "lookup Wave",
                    "author": "",
                    "readme": {
                        "en": "Use slider to scrub through Wave CHOP"
                    }
                },
                "1": {
                    "title": "single wave",
                    "author": "",
                    "readme": {
                        "en": "single-cycle waves, some are repeating, some not.\n\nall are 600 samples long  which become 10 seconds since the sample rate is 60 set to samples/sec."
                    }
                },
                "2": {
                    "title": "easeinout",
                    "author": "",
                    "readme": {
                        "en": "ease-in and ease-out with a Hold  extend condition at the start-end.\n\nIt is often used as a lookup table.\n\nAnd when you use the easeinout for both the lookup table and index, you get tighter and tighter rises, keeping the slopes smooth."
                    }
                }
            }
        }
    },
    "COMP": {
        "animationCOMP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "animation",
                    "author": "",
                    "readme": {
                        "en": "work-in-progress\n"
                    }
                }
            }
        },
        "blendCOMP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "weighted blend",
                    "author": "jarrett",
                    "readme": {
                        "en": "In this example, the blend objects; blend2 and blend3, are using a type (mode) of \"blend\" which means each transform may be blended using a blend weight. \n\nUse switch1 to choose between blending between each input in sequence or blending randomly between two randomly selected inputs.\n\nThe 9 blend mask parameters can be individually toggled to remove specified tranform components from being passed along -ie only pass through translations or scales etc. "
                    }
                },
                "1": {
                    "title": "sequence blend",
                    "author": "jarrett",
                    "readme": {
                        "en": "In this example, the blend objects; blend2 and blend3, are using a type (mode) of \"sequence\" which means a floating point number between 0 and 3 is used to indicate which input to blend to. \n\nThe 9 blend mask parameters can be individually toggled to remove specified tranform components from being passed along -ie only pass through translations or scales etc. "
                    }
                }
            }
        },
        "boneCOMP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "basic bone",
                    "author": "jarrett",
                    "readme": {
                        "en": "In this example: a simple 4 bone rig is constructed inside the boneChain0 object.\n\nTo view the boneChain in a floating window right click on the boneChain0 component and click the \"View... menu item.\n\nFor more information reference the help dat found in boneChain0 object."
                    }
                },
                "1": {
                    "title": "spider",
                    "author": "jarrett",
                    "readme": {
                        "en": "to come"
                    }
                }
            }
        },
        "bulletsolverCOMP": {
            "num_samples": 18,
            "examples": {
                "0": {
                    "title": "bouncing",
                    "author": "eric",
                    "readme": {
                        "en": "A simple example to demonstrate collision between two Actor COMPs. Ball is a dynamic Actor COMP and Floor is a static Actor COMP (infinite mass). Ball will simply fall on Floor due to the gravity applied via the Bullet Solver COMP.\n\nIn order to start the simulation click the Start Sim pulse on the Bullet Solver COMP.\n\nRestitution is how much energy is conserved when a collision occurs.\n\nBall and Floor both have restitution set to 1, so in this case Ball will bounce away at the same speed.\n\nNote: restitution is multiplicative between the two colliding objects, so if Floor's restitution\nis 0 then the Ball will not bounce at all."
                    }
                },
                "1": {
                    "title": "friction",
                    "author": "eric",
                    "readme": {
                        "en": "actor* are laid out in a grid with different combinations of rolling friction and friction.\n\nNote: Play with the friction/rolling friction parameters on the floor COMP to get varying results.\n"
                    }
                },
                "2": {
                    "title": "instancing",
                    "author": "eric",
                    "readme": {
                        "en": "This demonstrates Actor COMP instancing. Each instance is a separate entity to bullet. Hit the Start pulse on the Bullet Solver COMP to start the simulation.\n\nThe Bullet Solver COMP has two Actor COMPs inside: Blocks and Floor, and the solver's Actors parameter './*' points to the two COMPs. Blocks are instanced from the Box SOP to build a 4x12x4 grid og blocks from an individual block. The Blocks COMP is then translated 10 units up so that it will fall on the Floor. \n\nThe force being applied is from the gravity parameter on the Bullet Solver COMP. Friction parameters are at 1 for both the Blocks and the Floor so that the Blocks don't slide around.\n\nNote: if you change the node that an Actor COMP is instancing from (the Box SOP here) you will need to pulse its Initialize Actor parameter to update from your changes."
                    }
                },
                "3": {
                    "title": "impulse forces",
                    "author": "eric",
                    "readme": {
                        "en": "A slight variation on the instancing Snippet. This example demonstrates the use of the Impulse Force COMP. \n\nThe only force in this simulation is the Impulse Force COMP in bsolver1: impulseforce1. There is no gravity. \n\nimpulseforce1 will be applied to all the Blocks once pulsed. This can be done either on the node or through the Pulse Force button. \n\nNote: Continuous Collision Detection is toggled on the Blocks so the high velocity from the impulse force doesn't clip them through the Floor."
                    }
                },
                "4": {
                    "title": "forces",
                    "author": "eric",
                    "readme": {
                        "en": "A slight variation on the instancing Snippet. This example demonstrates the use of the Force COMP. \n\nIn addition to gravity being applied, there is a force being applied to each block using a Force COMP: force1 in bsolver1.\n\nforce1 applies both rotational force (torque) and linear force. The force from force1 is applied continuously each frame unless deactivated, which can be done with the Force button."
                    }
                },
                "5": {
                    "title": "bridge",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates the Constraint COMP, specifically hinges. \n\nIn this simulation there are 5 blocks that are instanced on the Blocks Actor COMP, and a Ball Actor COMP, all inside bsolver1. The Ball simply falls on the bridge in this simulation, and because of the constraints put in place, the bridge will hold the ball up. \n\nThe bridge is created from the 5 blocks using the Constraint COMP to create hinges. Note that they must be hinges in this case because we only want the Blocks to rotate around the Z axis. If it were a point to point constraint then they could rotate along any axis and as a result the ball would fall off.\n\nconstraints_between is used to create 4 hinges between the 5 blocks. It is a body to body relationship between bodies on bsolver1/Blocks. The bodies parameter is a list of body IDs and is a 1 to 1 mapping with the other bodies parameter. So, on constraints_between we are creating 4 versions of the same hinge between 0 and 1, 1 and 2, 2 and 3, and 3 and 4. The pivot points are how we connect the bodies. We are connecting the right side of the first body to the left side of the second body, using the size of box1 inside the Blocks COMP as the boundary.\n\nFinally, we add a hinge constraint to the left and right ends so that the bridge is held up. Because these constraints are not body to body, the far left and right bodies will be pinned to the world at that position, unable to move. As a result they will hold up all the other blocks.\n"
                    }
                },
                "6": {
                    "title": "ball and chain",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates Point to Point constraints on the Constraint COMP. \n\nWe create a chain by instancing chain links (from a torus) on the Chain COMP in bsolver1. The chains are constrained together from end to end in between_links. \n\nThen the top link is constrained to the world in top_chain_link so the chain will not fall. At the other end, chain_to_ball constrains the Ball COMP in bsolver1 to the last chain link. \n\nThe Ball is given an initial velocity so the behavior of the chain is immediately visible."
                    }
                },
                "7": {
                    "title": "car",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates how a Constraint COMP can be used to create wheels. \n\nClick Start on bsolver1.\n\nFour wheels are instanced in the Wheels COMP in bsolver1, and four Constraint COMPs are used to attach the wheels to the Chassis COMP (front_left, front_right, back_left, back_right). \n\nHinge constraints are used so the wheels will only rotate in the X axis. \n\nInitial velocity is given to the Chassis, and the wheels begin to roll along the ground. Wheels and Ground COMP are given rolling friction so that the car will eventually stop. If these are lowered then the car will move further."
                    }
                },
                "8": {
                    "title": "feedbacking",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates a simple feedbacking network on the torus COMP in bsolver1. \n\nEverytime the 'Slow Down Torus' button is pressed, the Y velocity of the torus will be multiplied by 0.75, slowing it down. \n\nThis is done by first grabbing the current velocity of the torus using the Bullet Solver CHOP. vel_ty (linear y velocity) is selected and a switch is exported with the button value. \n\nWhen it's pressed, math1 (which has 75% the velocity) will be used instead of select1, and this subsequently overrides the old velocity in merge1 and then null1 feedbacks the values into the Actor COMP. \n\nThese feedback values will update the Actor COMP's physics data at the beginning of the next frame. So when the button is pressed, the next frame the Actor COMP will be updated with 75% of the velocity."
                    }
                },
                "9": {
                    "title": "driving car",
                    "author": "eric",
                    "readme": {
                        "en": "This is an extension of the car example. \n\nUser interaction is added using the feedbacking system. A runway is created for the car, and the car can be moved forward using the up arrow. \n\nWhen the up arrow is pressed 1000 linear is applied to the Chassis COMP in the x direction, and 250 torque is applied to Wheels COMP on the z axis. \n\nThis feedbacking system is different than feedbacking1 because it doesn't require any physics info from the Actor COMP. It is not as much as a feedbacking loop, it is more one-directional. It only needs the IDs of the bodies and Actor COMP and the appropriately named force channels so it can be applied."
                    }
                },
                "10": {
                    "title": "concave vs convex",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates the difference between a concave body and a convex one.\n\nIn the concave Bullet Solver COMP, actor2's Collision Shape is Automatic, which means it will be created as a concave shape. Display Collision Shape is toggled on so you can see what is created.\n\nIn the convex Bullet Solver COMP, actor2's Collision Shape is Convex Hull, meaning that the collision shape is no longer \"hollow\" and as a result the ball will just bounce on the top.\n\nNote: only static bodies can be concave. For a dynamic body to be concave it must be composed of convex parts."
                    }
                },
                "11": {
                    "title": "2D attraction",
                    "author": "eric",
                    "readme": {
                        "en": "This examples demonstrates both a 2D simulation, and how the feedbacking system can be used to create an \"attraction\" system. All this is done in bsolver1.\n\nIn this example, the blocks are all attracted to their initial position. The slider is used to control the attraction. When the slider is at 0 the blocks will act as if there is no attraction, and just fall as normal. If the slider is at 1 then the blocks will be at their original position (in the default case a B).\n\nThe blocks are created using instancing on the blocks COMP in bsolver1. They are instanced from the letter B through a SOP to CHOP. These values are then used as the initial positions of the blocks.\n\nThe feedbacking system works as follows:\n\n1. bulletsolver1 grabs the physics information from the blocks COMP.\n\n2. select1 selects the transform (tx, ty, rz only because the simulation is 2D). A vector is created between the blocks current transform (from select1) and its original position recorded in null1 by subtracting null1 from select1 in math1. The range is then modified in math1 using the value from the slider.\n\n3. select3 selects the current velocity of the blocks from the Bullet Solver CHOP. This value is scaled down using the range parameter in math4 and the slider.\n\n4. The scaled current velocity in math4 and the velocity calculated in math1 are then added together in math2. This is the velocity we feedback to the blocks COMP. \n\n5. First we have to merge bulletsolver1 (it has the body IDs and actor ID which are required for feedbacking) with the new velocity with replace first with last mode selected. to_feedback is then fed back into blocks. These will be the new velocities of the blocks at the next frame. "
                    }
                },
                "12": {
                    "title": "turbulence",
                    "author": "eric",
                    "readme": {
                        "en": "This simple example demonstrates how forces can be used to simulate turbulence or other vector fields.\n\nIn bsolver1, we have a group of instanced blocks from the Block COMP. \n\nWe grab the current position of each body, and apply force to it based on its current position by using a Noise CHOP. This force is applied when null1 is fed back into Blocks."
                    }
                },
                "13": {
                    "title": "ccd",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates the use of the Continuous Collision Detection toggle on the Actor COMP. \n\nIn the simulation, Block_A in bsolver1 has Continuous Collision Detection enabled, while Block_B does not. In the simulation, Block_A is top block, and Block_B is the bottom one. \n\nThe Pulse Force toggle will apply an impulse force to both blocks in the negative X direction. Block_B will clip through while Block_A will not.\n\nThis is because continuous collision detection performs collision detection between an object's position at the start and end of the frame. This is in contrast to discrete collision detection, which is only performed at the beginning and end.\n\nNote: Continuous collision detection is not as performative as discrete collision detection, so it isn't always suitable.\n\nThe Box is created with a Box SOP as the collision shape, but what is displayed/rendered is the same box with the front missing."
                    }
                },
                "14": {
                    "title": "recycler",
                    "author": "eric",
                    "readme": {
                        "en": "What goes out, comes back in. via the Limit CHOP in recycler/bsolver1 that loops position of the instances.\n\nrecycler/colliders are the black stationary collision objects.\n\nAlso, a fraction of the wood blocks are not affected by the wind force. The samples in recycler/bsolver1 are split off in to 2 groups, some affected by wind, the rest not.\n\nAnthough this is a 2D sim, some boxes are forced to move in Z if the tz slider is moved.\n\nA collision box, recycler/cambox at the camera prevents blocks going through camera. cambox is included in the Bullet Solver COMP's collision objects parameter.\n\nThe primitive collision sounds suck, so they are turned off. But you can see that there is a channel indicating that an instance is colliding with something else.\n\nWHen running the sim, pause it by making the sim speed = 0.\n\ndefault sim is 2D, change Dimension on solver to 3D and press Go.\n\nrecycler/bsolver1/math_dampen slows things down by .2% per cook (mult by .998), like the effect of wind friction. (It's technically more correct to make it 1 - .002 * number_of_frames_of_timeslice.)"
                    }
                },
                "15": {
                    "title": "chain",
                    "author": "eric",
                    "readme": {
                        "en": "This example shows how to make dynamic concave collision bodies. To do this a compound collision shape is used out of 4 boxes in bsolver1/actor1/geo1.\n\nThese are merged together to be used as an input to the torus, which will be used for display/rendering only.\n\nThe toruses are instanced using a Line SOP."
                    }
                },
                "16": {
                    "title": "simple force",
                    "author": "greg",
                    "readme": {
                        "en": "Bring up a floating viewer of playWithForces (rclick -> View...)\n\nGo into playWithForces.\n\non bsolver1, click Init Sim, then Start Sim. Due to force1, the box will move vertically.\n\nTurn off Active parameter on force1.\n\nClick Start Sim again. Turn on the Active parameter of force2. Because the Relative Position parameter of force2 is set to +1 in X, and the force is in +y, it will push up on the right side of the box, and cause it to rotate around the Z-axis.\n\nMake force2 Active off. Start Sim again.\n\nTurn on Active of force3. This will make it rotate only, as Torque is set to +Z.\n\n"
                    }
                },
                "17": {
                    "title": "particle collision callback",
                    "author": "eric",
                    "readme": {
                        "en": "This example illustrated how to use the colliosion callback and create simple repeating particle emission.\n\nA Sphere SOP is used to create the bodies on the Actor COMP. The Speed CHOP is reset (Reset parameter) when the simulation is not \"running\" (bsolver1's Info CHOP 'running' channel).\n\nCollision callbacks are used on the Bullet Solver COMP to create the emission looping effect. Once a body collides with the floor, their position is set to the default position (0, 10, 0)."
                    }
                }
            }
        },
        "buttonCOMP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "tuik binary",
                    "author": "",
                    "readme": {
                        "en": "tuiktoggle and tuikpulse is similar to the look of the On/Off buttons in the TouchDesigner UI. They are slight modifications to 'binary'.\n\n\nFor more info on tuiktoggle, see binary in README_binary.\n\nfrom Palette/gal"
                    }
                },
                "1": {
                    "title": "binary radio menu",
                    "author": "",
                    "readme": {
                        "en": "Here are six button-type gadgets groups, each of which has multiple appearances: binary, radio, menu, label, string. tuiktoggle and tuikpulse are mods of binary.\n\nfrom Palette/gal.\n\nThey are binary (toggles, momentary, pulses), radio buttons (outputs an integer), menu (pops up a set of radio buttons), label and string.\n\nThe gadgets here for example:\n\n'binary' can be momentary, toggle, or run a script when pressed. It can have a label on either side, or not, It can be horizontal or vertical like the sliders. The indicator can be text or image icons or both, with default icons.\n\n'label' is just a text string with no output, can be horizontal or vertical as well.\n\n'radio' contains a set of binary gadgets, can be arranged in grids with label/heading, and can output tokens as well as the integer channel. Each radio button can be text and/or an image.\n\nAlso 'radio' can be defined using a table, or more easily, a list of names or icons specified in a parameter, for example ['A', 'B']. \n\nA command (in the Run Command parameter) can be run for any 'binary', 'radio' or 'menu' button press, or you can run a separate command per radio/menu button by putting the command in the 'command' column of the input table. in 'radio' and 'menu' you ca used the variable 'index' ti identify which button was pressed.\n\n'menu' contains a 'radio' gadget and extra controls to bring it up in a window and close it when something is selected or focus is changed."
                    }
                },
                "2": {
                    "title": "string labels",
                    "author": "",
                    "readme": {
                        "en": "'string' lets you enter a simple text string for labelling.\n\nfrom Palette/gal"
                    }
                }
            }
        },
        "cameraCOMP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "ortho perspective",
                    "author": "",
                    "readme": {
                        "en": "A perspective camera will cause objects farther away to be smaller, while an orthographic camera shows no size difference regardless of how far away the object is.\n\nLook at the sopRender component in the Palette (Tools/sopRender)."
                    }
                }
            }
        },
        "camerablendCOMP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "camera blend",
                    "author": "",
                    "readme": {
                        "en": "The Camera Blend COMP will blend both the camera's transforms as well as the projection types. In this example we are blending between a perspective and an orthographic projection"
                    }
                }
            }
        },
        "containerCOMP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "fill proportional",
                    "author": "rob",
                    "readme": {
                        "en": "In grid, we want to arrange 5 panels vertically, with each component occupying some fraction of the height.\n\nThe children panels in \"grid\" fit the width of the parent because their Horizontal Mode is set to Fill, and on \"grid\"'s Children page, Align is set to Top to Bottom.\n\nNote that all 5 panels in \"grid\" are clones of container1. (They don't have to be)\n\nThen vertically, we want each container1-container5 to occupy a different fraction of the vertical space. So you sett their Vertical Mode to Fill, and each container has a different Vertical Fill weight, like .1, .2 etc. \n\nThe Vertical Fill Weights of all 5 don't have to add up to 1, they are just proportional.\n\nTheir order is determined by the component's Align Order parameter, where the lowest number is first.  \n\nIf some nodes have the same Align Order parameter value as it does here (they are default 0), it then uses the alphanumeric node name to determine the order, where container3 follows container2.\n\ncontainer1 is at the bottom because \"grid\"'s Align menu is Bottom to Top.\n\nBecause each container1-container5 have their width and height set in this way, their X, Y, Width and Height parameters are disabled.\n\nYou can still get their computed values by using these python members, say for container2: container2.x, container2.y, container2.width, container2.height. That's how you see their resolutions in the text of the component.\n\nYou can bring up grid in a floating window and pull the edges of its window to resize the container, and the enclosed container1-container5 will adjust accordingly.\n\n"
                    }
                },
                "1": {
                    "title": "anchors sizing",
                    "author": "rob",
                    "readme": {
                        "en": "We again want to fill the panel vertically with 5 containers inside, but on container1-container4, this uses Anchor parameters to specify the exact fraction of the height of the parent, and container5 is set to Fill the rest of the vertical space.\n\nIt still uses the Top to Bottom setting of the parent to position each container.\n\nChange container3's Top Anchor parameter.\n\nYou can also specify the sizes in pixels using Top Offset."
                    }
                },
                "2": {
                    "title": "swipe touch screen",
                    "author": "markus",
                    "readme": {
                        "en": "Here are two touchscreen Slider panels. One for Horizontal and one for Vertical. \nAll the touch screen (and/or mouse) swiping is done inside the swipe container which is an overlay over the actual content. \n  \nThe swipe container has an extension which mainly records if a swipe or a click has occurred. If a click has occurred, it is being send from the MultiTouchIn DAT to the content container. Otherwise the interaction is solely handled by the swipe network. \n"
                    }
                }
            }
        },
        "environmentlightCOMP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "environment light",
                    "author": "jarrett",
                    "readme": {
                        "en": "The environment light is central to working with PBR materials. This  render uses simple settings. The cloud environment map is the generic environment map that is included with TouchDesigner.\n\nEverything in this scene is extremely default so look through each node to discover how quick and easy it is to setup a good looking render.\n\nA secondary distant light source - which is called light1 gives a directionality to the light. Notice how you control the specular highlight location on the right side ball when you change the orientation of the distant light source.\n\nUse projection1 to rotate parameters to transform the enviornment light to you liking. \n\nUse HSVAdjust to modify the overall tempurature of the scene. Modify the saturation parameter and see how that affects the tone of the lighting.\n\nNotice how the PBR material parameters - specular, roughness and mentalness have a profound effect on the surface look once everthing is rigged properly.\n\nRotate the environment light using the environment map rotate parameters for fast and dramatic effect.\n\nThe SSAO post effect is very important to help the balls sit nicely on the ground. No shadows are required to nicely render a scene like this.\n"
                    }
                }
            }
        },
        "fbxCOMP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "fbx",
                    "author": "jarrett",
                    "readme": {
                        "en": "The SixShadedObjectsLowRes component is an FBX asset being read from disk. When an FBX archive is read into an FBX component data may be extracted and writen back to disk into the current project folder under a folder name TDImportCache. \n\nAs the asset is read into TouchDesigner a Python callback script maybe be used to modifiy the incoming archive assets.  This can be very useful in order to reform the asset to work more cleanly with TouchDesigner paths for things like materials and texture references.\n\nIn this example the SixShadedObjectsLowRes_callbacks script is setup to search for any geometry components that have a material reference and if it finds a matching name for a pbrMAT in the root of this component it will modify the material refernce inside the FBX asset to point at the material found in the root of the asset.  This makes working with the materials easier as they are all found in one location."
                    }
                }
            }
        },
        "fieldCOMP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "enter string",
                    "author": "",
                    "readme": {
                        "en": "The idea here is that you are making the gadget tied to a certain cell of a certain DAT. So you specify the DAT, row and column. You can change these on the fly and the gadget will hook to some other cell.\n\nThe parameter \"Value\" is always kept consistent with the cell, and the same cell value is output from the gadget as its first output (a 1-cell DAT). \n\nBy default the cell is inside the gadget, so you can just use gadget UI edit set a text string that is output from the gadget and sets the \"Value\" parameter.\n\nModifying the Value parameter updates the UI and the DAT cell, wherever it is."
                    }
                }
            }
        },
        "flexsolverCOMP": {
            "num_samples": 9,
            "examples": {
                "0": {
                    "title": "simple",
                    "author": "eric",
                    "readme": {
                        "en": "A simple fluid example. fsolver1/actor1 is instanced using a teapot. The teapot is subdivided to give it more points.\n\nfsolver1/actor1 is a particle Actor COMP, which is enabled via the Particle parameter on the Flex page. actor1 is rendered as a low-poly sphere. In the case of a particle Actor COMP the display SOP is never used for the collision shape. The collision shape for particles is determined by the value of its solver's Particle Radius parameter.\n\nThe Nvidia Flex Solver allows scene boundaries to be created, up to 6 total. Each plane defaults to an XY plane facing +Z. Rotation and Translation parameters can change the transform of the default plane.\n\nWhen the simulation is running, move the mouse to apply forces.\n\nFlex TOP is used to demonstrate how to grab position data from an Actor COMP. The Flex TOP is used as the instance OP for geo1 to demonstrate how to use the position data in the texture. It's an RGBA 32-bit texture where R=xpos, G=ypos, B=zpos, and A=0"
                    }
                },
                "1": {
                    "title": "emission",
                    "author": "eric",
                    "readme": {
                        "en": "This example is similar to simple, except the Actor COMPs are Fluid Emitters instead of just Fluid. We have four Actor COMPs, each one an emitter. Each emitter is allocated 25000 particles.\n\nEmission works by recycling old particles and bringing them up to the emission origin. The number of particles in the emission cycle is determined by the Max Emission Particles parameter of the Actor COMP.\n\nEmitter world position and direction is calculated from the Actor COMP's transform."
                    }
                },
                "2": {
                    "title": "emission 2",
                    "author": "eric",
                    "readme": {
                        "en": "This example adds on to the previous emission example, except with only one emitter with 100000 particles. A static triangle mesh shape is added for the particles to collide with. \n\nThe Dissipation parameter is increased on fsolver1 to give the fluid a thicker texture.\n\nPre-Roll is added so that the simulation begins in a somewhat stable state. Pre-Roll will step the simulation forward by the amount of desired seconds, performing a certain number of simulation steps per frame. This is designed to get into a stable start state without having to play araound with initital positions of particles. \n\nThe state of the pre-roll can be retrieved from fsolver's info CHOP. If inititalizing=1 then pre-rolling is being done. If pre-roll is interrupted during this time it will be recalculated. When pre-roll is done initializing=0 and ready=1."
                    }
                },
                "3": {
                    "title": "bowl",
                    "author": "eric",
                    "readme": {
                        "en": "In this simulation, instead of planar boundaries a triangle mesh hemisphere is added to catch the particles. \n\nThe max speed parameter on fsolver1 is set so that the particles won't clip through when falling.\n"
                    }
                },
                "4": {
                    "title": "particle mixture",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates how particles of different weights will mix. When of the same weight they mix fairly evenly. But with a heavier white particle, white is at the bottom and blue is on top."
                    }
                },
                "5": {
                    "title": "camera emission",
                    "author": "eric",
                    "readme": {
                        "en": "This example shows how to emit first-person from a camera. The arcBallCamera COMP is used for its improved camera movement controls.\n\nactor1 is a Fluid Emitter, and its transform is parented by cam1 so the emission transform will change with the movement of the camera. actor1's transform is offset so the emission particles don't obscure the camera view.\n\nThe emission is along actor1's z axis. The camera viewing angle is set to 75 degrees."
                    }
                },
                "6": {
                    "title": "force field",
                    "author": "eric",
                    "readme": {
                        "en": "This example shows how force fields can be used in a simulation.\n\nForce fields have a transform as well as a radius. Positive force field strength pushes objects out from the force fields, whereas negative strength pulls objects toward the center. \n\nIn this example we want negative strength to pull fluid particles in. We grab the Low frequency channel from the audioAnalysis palette COMP and then remap that to a more reasonable forcefield strength range and export it to the Strength parameter on forcefield1.\n\nLinear falloff is added to linearly reduce the force around the force field edges, to create smoother movement."
                    }
                },
                "7": {
                    "title": "diffuse",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates the usage of diffuse particles.\n\n2 Geo COMPs are used: fluid instancing from the fluid particle position texture (positions), and diffuse instancing from the diffuse particle position texture.\n\nThe particles are rendered as a single point using a point sprite MAT. fluid has additional color attributes taken from density, to add extra depth to the rendered output."
                    }
                },
                "8": {
                    "title": "vortex",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates how to create a vortex effect with a force field.\n\nTo achieve this, Vorticity Confinement is lowered to 5. The lower the Vorticity Confinement, the more rotational force particles will experience around the force field center.\n\n(hard to control. this snippet needs some more work!)"
                    }
                }
            }
        },
        "geometryCOMP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "instancing",
                    "author": "",
                    "readme": {
                        "en": "Instancing takes a geometry (SOP) and places a copy (instance) of it at a position/rotation/scale defined by the CHOP channels. \n\nFor example in the Geometry COMP's Translate X parameter, you would set it to 'tx', or whatever the x position channel is named."
                    }
                },
                "1": {
                    "title": "texture instancing",
                    "author": "",
                    "readme": {
                        "en": "Texture instancing takes a geometry (SOP) (template) and a set of TOPs, and places a rectangle (instance) of the rectangle at a position/rotation/scale defined by the CHOP channels. \n\nPlus it's textured using an integer index that selects which texture to use for the instance."
                    }
                },
                "2": {
                    "title": "2dTextureArray",
                    "author": "",
                    "readme": {
                        "en": "Here's an example of instanced geometry that's textured with a single Texture 3D TOP that's holding movie frames in a 2D array.\n\nIt's set to be running, but you can play with stopping the movie player, stopping the active state on the 3d texture, or a combination of those to change the resource cost of this approach. "
                    }
                },
                "3": {
                    "title": "instance from TOPs",
                    "author": "",
                    "readme": {
                        "en": "Here's an example of instanced geometry that gets its XYZ position values from a TOP.\n\nRight-click on render1 and select View...\n\nWe're making a grid of 64 x 64 instances in XY, where an image is offsetting the boxes in Z. Each pixel of toGeoXYZ is an instance.\n\nreorder1 assembles a horizontal ramp in red (which will be mapped to the x position of each instance), a vertical ramp in green for Y, and a Z-displacement in the blue channel. We don't need the alpha channel.\n\ntoGeoXYZ is 64x64 pixels giving a set of 64x64 instances. It is made of floating point pixel values (set on the Common page of the Math CHOP), and is re-ranged to be -1 to +1.\n\ntoGeoColor specifies the color on geo1's Instance 2 page. It also has to be the same resplotion as geoXYZ.\n\nblur1 softens the Z-displacements only (see Channel Mask on the Common page only affecting Z)."
                    }
                }
            }
        },
        "lightCOMP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "basic and cone",
                    "author": "",
                    "readme": {
                        "en": "Point light, cone light, cone light with softness."
                    }
                },
                "1": {
                    "title": "projection",
                    "author": "",
                    "readme": {
                        "en": "THis combines using an image like a slide-projector within a cone light."
                    }
                },
                "2": {
                    "title": "attenuated",
                    "author": "",
                    "readme": {
                        "en": "Light reduced by distance."
                    }
                }
            }
        },
        "listCOMP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "run per row",
                    "author": "",
                    "readme": {
                        "en": "Take table input and make component that executes a script for each row clicked."
                    }
                },
                "1": {
                    "title": "lister widget",
                    "author": "",
                    "readme": {
                        "en": "A Lister Widget shows a lister use case designed to allow, for example, programming a scene change sequence.  There is no actual functionality except for the editing the scenePlaylist DAT.\n\nOpen the example by right clicking on the example parent component and click \"View...\" from the popup menu.\n\nYou can edit cells and drag-drop rows to other rows to reorder the scenePlaylist DAT. \n\nThe data that is managed by the lister in stored in the scenePlaylist DAT. This DAT is referenced by the sequencerLister Widget component. \n\nThe sequenceLister widget is customized using the Edit Config COMP, Edit Column Definitions and Edit Callbacks buttons to access these two sub-assets.\n\nThe configSequencer COMP provides Table TOPs to configure the cell looks of the table.\n\nYou can edit cells and drag-drop rows to re-order.  \n\nThe colDefine DAT is a table that provides configuration settings for the table behavior.\n \nThe callbacks DAT in configSequencer provides Python callbacks that are called when various events happen, for example when the data is loaded, or a cell is clicked.\n\n- Ease of Use Features -\n\nThe Input \"Table Has Headers\" parameter makes working with DATs much easier, as the sourceData row in the Column Define DAT can match the names of the data storage DAT that is assigned using the \"Input Table DAT\" parameter. Once this link has been made features like \"Drag To Reorder Rows\" and \"Selectable Rows\" will be much easier to manage."
                    }
                }
            }
        },
        "parameterCOMP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "parameter",
                    "author": "",
                    "readme": {
                        "en": "parameters in panels - scope which parameters."
                    }
                },
                "1": {
                    "title": "self-contained parameter panel",
                    "author": "greg",
                    "readme": {
                        "en": "hueControls is a panel containing a set of parameters, and the UI of hueControls is defined with a Parameter COMP that is located inside hueControls, and exposed via the Operator Viewer parameter on hueControls (slight brain-twister).\n\nright-click on HueControls and select View..."
                    }
                }
            }
        },
        "replicatorCOMP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "replicate movies",
                    "author": "",
                    "readme": {
                        "en": "simple replicator creating copies of a MovieIn TOP and fetching their file path from the template table."
                    }
                },
                "1": {
                    "title": "replicate UI",
                    "author": "",
                    "readme": {
                        "en": "A replicator uses the template table to look up which node to clone to its copy."
                    }
                },
                "2": {
                    "title": "replicate components",
                    "author": "",
                    "readme": {
                        "en": "This is a replicator making copies of  a Component, each copy which contains a replicator.\n\nThis generates an image for all files in a folder, separated by image file type (by suffix).\n\nThis can be extended to make s separate viewer type for each file type. Currently they all use Movie File In TOP. "
                    }
                },
                "3": {
                    "title": "by name by index",
                    "author": "",
                    "readme": {
                        "en": "Change the Index parameter in switchtable from 1 to 2 to 0 to see the effect of changing the table.\n\nReplicator creates a copy of node for every row in a table, and responds every time the table changes. You specify a master component plus the table you want to drive the replication.\n\nIt will create one component for every row in the table specified in \"replicator\" by \"Template Table\".\n\nYou have a master component, specified in Replicator by \"Master Node\".\n\n------- flavor 1 - replicator1 ------------\n\nClones will be named/numbered sequentially with the prefix specified in Replicator by Node Prefix\n\n------- flavor 2 - replicator2 ------------\n\nClones will be named based on the string in a column of the table, specified in Replicator by Column Index. Column numbers start from 0.\n\n-------------------------------------------\n\nIt will delete nodes that are no longer needed.\n\nSet Ignore First Row to ignore the first row of the table.\n\nThe replicants get laid out in a grid in the network. You can set where that grid starts.\n\nEach replicant is different as it uses expressions to select its color and text string. \n\nmaterthing2 has its Clone parameter set, so its replicants are clones of masterthing2."
                    }
                },
                "4": {
                    "title": "event replicate",
                    "author": "",
                    "readme": {
                        "en": "See in the Event CHOP's OP Snippets the \nexample \"event replicate\"."
                    }
                }
            }
        },
        "selectCOMP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "select component",
                    "author": "",
                    "readme": {
                        "en": "A bunch of ways to select between a set of panels.\n\n\nselect1 and select2 have different expressions in their Select Panel parameter but they do the same thing. Change the value of chan1 in constant1 to between 0 and 2.\n\nselect3 keeps the panel index in the custom parameter, restricted to a range of integers, 1 to 3.\n\nselect3 also makes sure it is the same resolution as the panel it is selecting: Look at select3's Width and Height parameters. Both expressions for width and height do the same thing, it's just different forms of python.  Highlight portions of the strings to see what they evaluate to.\n"
                    }
                }
            }
        },
        "sliderCOMP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "two way basic",
                    "author": "",
                    "readme": {
                        "en": "Operating the slider will change the Period parameter of wave1 by panelexec1.\n\nChanging the Period parameter by hand will change the slider using .click() in parexec1."
                    }
                }
            }
        },
        "usdCOMP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "basic usd",
                    "author": "jarrett",
                    "readme": {
                        "en": "This basic example loads a USD (Universal Scene Description) when the file path is changed and Import is pulsed. \n\nusd1 is a hierarchy of objects as separate Geometry COMPs.\n\nIf you select Merge Geometry and re-Import, it will put all possible geometry into one SOP with point colors set.\n\nusd2 has been transformed so that Y is 'up' in toaster-land."
                    }
                },
                "1": {
                    "title": "usd mod instances",
                    "author": "jarrett",
                    "readme": {
                        "en": "This example imports a rocks USD (Universal Scene Description) geometry asset.  Inside the rocks_callbacks script there is a commented out line - \n\n#comp.op('Rock_0').par.instanceop = '../instances'\n\nRemove the # python comment delimiter and click the Import pulse parameter on the rocks USD component.\n\nThe rocks begin to fly around due to the instance position processor network that starts with a select operation that goes into the asset hiearchy and selects the instance attributes. \n\nThe rocks_callbacks script redirects the Rocks_0's Instance OP parameter to look at the 'instances' CHOP instead of the internal rocks/Instances operation."
                    }
                },
                "2": {
                    "title": "apple usdz over internet",
                    "author": "",
                    "readme": {
                        "en": "This will fetch a .usdz file on the internet from the Apple AR Dev site. \n\nIt uses the http:// URLs, which TouchDesigner understands in all plances where a file is read, like Movie File In TOP, Audio File In CHOP, etc.\n\nClick the Import pulse parameter, open the viewer and press h to home the geometry.\n\nCopy/paste usd2 to create usd3 and click Import to get the next usdz file in the list in 'paths'.\n\nThe paths to the usdz files may have changed by the time you try this, but you can search somewhere around https://developer.apple.com/augmented-reality/quick-look/ for more."
                    }
                }
            }
        },
        "windowCOMP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "multi-monitors",
                    "author": "greg",
                    "readme": {
                        "en": "This customized Window Component lets you easily place TOPs and panels in a single window spanning across multiple output monitors/projectors. You place one TOP or panel per monitor/projector. You don't have to mess with screen coordinates, sizes, or adapt to changing layouts and resolutions.\n\nAs you plug in monitors, you will see them appear in the viewer, which is a proxy of what you will see in Perform mode.\n\nIt's easiest to lay out yor monitors in the Display Settings left-to-right, with your main desktop where you edit networks on the left. Monitors 1 2 and 3 have to be anywhere to the right of Monitor 0.\n\nIt assumes you author your networks on Monitor 0 in Desgigner Mode. \n\nBonus: When you flip between Designer and Perform Mode, your content stays up on Monitor 1+ and stays up without interruption, so your audience won't notice you making on-the-spot changes to your networks.\n\nQuick Start: \n\nAttach at least one extra monitor/projector and make sure you have Extend Displays on (Windows) or Mirror off (macOS).\n\nFor Monitor 1 (second monitor), drag-Drop your desired TOP or panel onto the parameter \"TOP/Panel for Monitor 1\". Click Open Window for Designer Mode. See output on Monitor 1. \n\nFor Monitor 0, Drag-Drop your desired TOP or panel onto the parameter \"TOP/Panel for Monitor 0\". \n\nThen click the parameter \"Make This be Perform Window\". (It will make this Window component be the one TouchDesigner uses when you go into Perform Mode.) Go into Perform Mode (press F1 or th esquare box at the top-left of TD). See the output on both displays. Press Esc to get out.\n\n\nClick \"Open Window for Designer Mode\". This is for displaying you content on monitor 1+ while you are in Designer Mode editing networks on the monitor 0 (left-most monitor).\n\nChange the parameter \"TOP/Panel for Monitor 1\" to another TOP.  You should see it on your second monitor.\n\nAdjust the parameter Identify TOP Outputs to verify monitor output 1.\n\nOptionally bring this Window COMP's parameters up in a floating Window.\n\nThen go into Perform Mode (F1). You can check Identify Outputs to verify your monitors.\n\nNow you can flip between Perform Mode and Designer Mode, and your Monitor 1 onward will keep the same content up without interruption.\n\nNote that with a splitter like Datapath FX4, you will have to combine 4 images into 1 \"monitor\".\n\n\ncurrent issues: \n---------------\n\nmay need to split the window for macOS into 1 per monitor.\n\nHandle case where primary is DPI-scaled and secondaries are not."
                    }
                },
                "1": {
                    "title": "two windows",
                    "author": "jarrett",
                    "readme": {
                        "en": "In this example there is a control window and an output window that would typically be sent to the projector.\n\nThe windowControl WindowCOMP has its V-Sync Mode disabled, while the main windowOutput window has V-Sync Mode enabled. Only one Window component should have V-Sync enabled (otherwise the windows will fight with each other for sync) and usually this is the window component that is spanning all display monitors to audience. Having V-Sync enabled will avoid tearing artifacts.\n\nBecause the control window has V-Sync disabled you may see tearing artifacts on this display but generally this is not an issue. \n\nNotice the WindowControl Open as Separate Window parameter is bound to the windowOutput component's Open as Perform Window pulse parameters.  The windowControl window should be opened as a separate window while the main windowOutput is opened as the main perform window."
                    }
                },
                "2": {
                    "title": "horizontal fill",
                    "author": "jarrett",
                    "readme": {
                        "en": "This setup will layout 1 panel per monitor as long as the Windows Display Settings dialog has each monitor aligned to the top of each monitor and they are stacked horizontally.\n\nThe layut container is the same size as the monitor size.  It gets its width from a CHOP export and directly from the Monitors DAT cell.\n\nClick the window1 parameter Open as Perform Window to activate the window."
                    }
                }
            }
        }
    },
    "DAT": {
        "Script": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "common",
                    "author": "",
                    "readme": {
                        "en": "Common things to create tables, modify, and add rows and columns that are composed from other cells."
                    }
                },
                "1": {
                    "title": "copy input and iterate rows",
                    "author": "",
                    "readme": {
                        "en": "Copy the input table and then iterate over the rows."
                    }
                },
                "2": {
                    "title": "iterate input rows",
                    "author": "",
                    "readme": {
                        "en": "In the first case, for each row of the input, create a new row for the output. In the second case row 1 to 5, column 'col1' is summed.\n\nThe first uses:\n\tfor r in range(1,table.numRows):\n\t\n\tr is a row integer to access the input table. \n\nThe second uses:\n\tfor row in table.rows():\n\t\n\trow is a list of cell in a row.\n\t\nThe first way of going through rows is more flexible because you can use any range of rows - it's starting at row 1 in this case. It's also better as you can access the column by name, which you can't in the second methof,"
                    }
                },
                "3": {
                    "title": "random",
                    "author": "",
                    "readme": {
                        "en": "Right click and \"Force Cook\" the Script DAT to generate more random numbers.\n\nThis example uses a Custom Parameter Integer slider to generate the number of rows."
                    }
                },
                "4": {
                    "title": "replace",
                    "author": "",
                    "readme": {
                        "en": "This example will take two inputs  and replace any rows in A with those found in B. "
                    }
                },
                "5": {
                    "title": "for all cells",
                    "author": "",
                    "readme": {
                        "en": "The first Script DAT iterates over all cells and replaces each string with its length.\n\nThen second Script DAT iterates over all cells of the first input and compares with the corresponding cell of the second input. "
                    }
                },
                "6": {
                    "title": "exclude",
                    "author": "",
                    "readme": {
                        "en": "This example appends all the rows in the input except rows containing a word in the Custom Parameter named 'Exclude' on the  'My Parameters' page in the Script DAT.\n\nThe 'Exclude' custom parameter takes a string as input, which in this case is a comma-separated list of words to exclude."
                    }
                },
                "7": {
                    "title": "shuffle",
                    "author": "",
                    "readme": {
                        "en": "This example shuffles the contents of each cell using\nthe seed value found in the 'Seed' Custom Parameter on\nthe 'Custom1' Parameter Page."
                    }
                }
            }
        },
        "chopexecuteDAT": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "CHOP to table",
                    "author": "",
                    "readme": {
                        "en": "The CHOP Execute DAT in this example is run every time the value changes in the CHOP that it is referencing.\n\nWhen it is run, it writes the value of that CHOP into a Text DAT."
                    }
                },
                "1": {
                    "title": "value change",
                    "author": "",
                    "readme": {
                        "en": "The CHOP Execute DAT in this example is run every time the value changes in the CHOP that it is referencing.\n\nWhen it is run, it writes the value of that CHOP into a Text DAT."
                    }
                },
                "2": {
                    "title": "on and off",
                    "author": "",
                    "readme": {
                        "en": "This example runs a Python function  when the value goes  from Off to On, and a different function when the value goes from On to Off.\n\nWhen the value goes from On to Off, it writes 'Off' to the Text DAT. When the  value goes from Off to On, it writes 'On'."
                    }
                },
                "3": {
                    "title": "while on or off",
                    "author": "",
                    "readme": {
                        "en": "This example is similar to the On to Off / Off to On example, except that the functions 'whileOff()' and 'whileOn()' run continuously while the value is On or Off.\n\nIn CHOPs, values that are 0 or less are Off, and anything greater than 0 is On.\n\nIn this example, every time either of the functions are run, it increments its corresponding value in the Constant CHOP."
                    }
                },
                "4": {
                    "title": "additional info",
                    "author": "",
                    "readme": {
                        "en": "Open your Textport and begin changing the values in the Constant CHOP. You can see all the information that is natively passed to the  Python functions when the valueChange() function is called."
                    }
                },
                "5": {
                    "title": "value difference",
                    "author": "",
                    "readme": {
                        "en": "Capture the most recent change in value of  incoming CHOP channels.\n\nThe CHOP Execute DAT conveniently provides the previous value when a CHOP value changes.\n\nClick sliders in the Constant CHOP."
                    }
                }
            }
        },
        "choptoDAT": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "rows and cols",
                    "author": "",
                    "readme": {
                        "en": "These examples get both names and values of the selected CHOP and create tables by row and by column."
                    }
                },
                "1": {
                    "title": "non timeslice",
                    "author": "",
                    "readme": {
                        "en": "This example takes all the samples across all the channels and creates a table with the values."
                    }
                }
            }
        },
        "convertDAT": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "text to table",
                    "author": "",
                    "readme": {
                        "en": "These two examples convert Text DATs to Table DATs, the first creating a new cell at every space, and the second, creating a new cell at every tab.\n\n"
                    }
                },
                "1": {
                    "title": "table to text",
                    "author": "",
                    "readme": {
                        "en": "These examples do the opposite of the above examples.\n\nThe first converts a table to text, putting a space where every cell split was.\n\nThe second uses an ellipsis for every cell split."
                    }
                }
            }
        },
        "datexecuteDAT": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "table change",
                    "author": "",
                    "readme": {
                        "en": "This example runs when any part of the table is changed.\n\nIt writes the name of the DAT that was changed to a Text DAT."
                    }
                },
                "1": {
                    "title": "row change",
                    "author": "",
                    "readme": {
                        "en": "This example runs when a row is changed.\n\nIt uses the passed variable 'rows' to print the index of the row that was changed. "
                    }
                },
                "2": {
                    "title": "col change",
                    "author": "",
                    "readme": {
                        "en": "This is very similar to the above example, except that it works with columns."
                    }
                },
                "3": {
                    "title": "cell change",
                    "author": "",
                    "readme": {
                        "en": "This function runs whenever a cell is changed.\n\nThere are many useful ways of querying the contents and information about the  changed cell. Two examples are written to a Text DAT when you change a cell."
                    }
                },
                "4": {
                    "title": "size change",
                    "author": "",
                    "readme": {
                        "en": "This example is run whenever the size of the physical table is changed."
                    }
                }
            }
        },
        "evaluateDAT": {
            "num_samples": 12,
            "examples": {
                "0": {
                    "title": "expression",
                    "author": "",
                    "readme": {
                        "en": "This example multiples all input cells by 2 using an expression."
                    }
                },
                "1": {
                    "title": "prepend and append",
                    "author": "",
                    "readme": {
                        "en": "The first prepends a string at the beginning of all cells.\n\nThe second adds a string before and after each cell value."
                    }
                },
                "2": {
                    "title": "prepend append",
                    "author": "",
                    "readme": {
                        "en": "This adds a string before and after each cell value."
                    }
                },
                "3": {
                    "title": "evaluate python",
                    "author": "",
                    "readme": {
                        "en": "You have the world of python string manipulation to affect cells. \n\nThe Scope page lets you leave the first row intact."
                    }
                },
                "4": {
                    "title": "input",
                    "author": "",
                    "readme": {
                        "en": "The expressions in the table plugged into the second input are performed on the corresponding cells  of the table plugged into the first input.\n\nIf there are more cells in the first input table, the last expression of the second inputs table is performed on the remaining cells. "
                    }
                },
                "5": {
                    "title": "python",
                    "author": "",
                    "readme": {
                        "en": "Aside from simple expressions you can also perform single line if statements with Python.\n\nme.inputCell.offset() allows you to grab nearby cells and use them in your expressions."
                    }
                },
                "6": {
                    "title": "variables",
                    "author": "",
                    "readme": {
                        "en": "This example expands useful members of some TouchDesigner built-in classes.\n\nGo to the python wiki page and see other variables in the App and Project classes."
                    }
                },
                "7": {
                    "title": "cycle",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates how to use an expression on all the rows of the first input, without affecting the header."
                    }
                },
                "8": {
                    "title": "scope",
                    "author": "",
                    "readme": {
                        "en": "This is better as it uses the Scope page to avoid affecting the first row."
                    }
                },
                "9": {
                    "title": "long cell expression",
                    "author": "",
                    "readme": {
                        "en": "You can call many different pieces of information about the input cell you're performing operations on, such as it's row, as well as being able to get information about function being run, such as it's location."
                    }
                },
                "10": {
                    "title": "examine row",
                    "author": "",
                    "readme": {
                        "en": "You can get row and column too."
                    }
                },
                "11": {
                    "title": "tscript",
                    "author": "",
                    "readme": {
                        "en": "Tscript was the original scripting language of TouchDesigner and is superceded by python.\n\nThis example expands tscript global variables.\n\nBEWARE, the Evaluate DAT's language is dependent on its inputs, no its Language parameter!"
                    }
                }
            }
        },
        "examineDAT": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "extensions",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates how to examine a Component's extensions.\n\nYou need to press the Re-Init  Extensions parameter in \"base1\" after editing the class definition in the \"utils\" DAT.\n\n"
                    }
                },
                "1": {
                    "title": "extensions portable",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates how to examine a Component's extensions.\n\nYou need to press the Re-Init  Extensions parameter in \"base2\" after editing the class definition in the \"base3/utilities\" DAT.\n\n"
                    }
                },
                "2": {
                    "title": "storage",
                    "author": "",
                    "readme": {
                        "en": "Right click and Run 'run_set_storage'.\n\nThis example demonstrates how to use Python storage to write variables to an operator.\n\nThe Examine DAT is then used to retrieve and parse that storage."
                    }
                },
                "3": {
                    "title": "local",
                    "author": "",
                    "readme": {
                        "en": "This example is similar to the above, except that we use 'text_examine_locals' own local storage, instead of using the storage of another operator, as well as using the first Examine DAT to see the raw data storage of the operator."
                    }
                },
                "4": {
                    "title": "IO",
                    "author": "",
                    "readme": {
                        "en": "This example shows the sys module's IO storage."
                    }
                },
                "5": {
                    "title": "sys modules",
                    "author": "",
                    "readme": {
                        "en": "This example allows you to see all the storage kept by the sys modules, including paths to the Python modules used in TouchDesigner."
                    }
                }
            }
        },
        "executeDAT": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "start",
                    "author": "",
                    "readme": {
                        "en": "This example is run when your project starts up.\n\n"
                    }
                },
                "1": {
                    "title": "creation",
                    "author": "",
                    "readme": {
                        "en": "This example is run on node creation.\n\nTo see it in action, copy and paste 'execute_when_this_node_is_created', and it will write the frame it was created on to a Text DAT."
                    }
                },
                "2": {
                    "title": "start of frame",
                    "author": "",
                    "readme": {
                        "en": "This example is run at the start of every frame."
                    }
                },
                "3": {
                    "title": "end of frame",
                    "author": "",
                    "readme": {
                        "en": "This example is run at the end of every frame."
                    }
                },
                "4": {
                    "title": "abs frame",
                    "author": "",
                    "readme": {
                        "en": "This example gets the absolute frame that the project is on at the start of every frame, and writes it to a Text DAT."
                    }
                }
            }
        },
        "fifoDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "fifo",
                    "author": "",
                    "readme": {
                        "en": "Open up the Textport and see the info that is passed in the callback fifo_script.\n\nRight-click on 'test_fifo' and select Run Script.\n\nThis example appends a row with the current frame number, to the bottom of the FIFO DAT. When it does this, it automatically deletes the current top row because the FIFO DAT parameter Maximum Lines is set to 4.\n\nThis is useful for creating a DAT table that acts similarly to a console window. "
                    }
                }
            }
        },
        "folderDAT": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "node per file",
                    "author": "",
                    "readme": {
                        "en": "In 'files', turn on the Active parameter.\n\nIt will list the folder contents once, which  then causes the Replicator 'replicate_files' to create one node for each file in the Root Folder.\n\nThe other set of nodes on the right include one component created for each folder in the Root Folder.\n\nIf either Folder DATs finds any files,  the Replicator component will create one new Folder DAT for each file (each row in the Folder DAT).\n\nin the Folder DATs, you can set Refresh on to let it monitor the folders continuously.\n\nFolder DAT 'folders' is like 'files' except it lists folders instead of files. Also 'folders' gets its Root Folder string from 'files' via an expression, and likewise 'folders' gets its Active parameter from 'files'.\n\nput a filesytem path in the Root Folder parameter of the 'files' node. Pulse the Active parameter. "
                    }
                },
                "1": {
                    "title": "asyncronous faster",
                    "author": "",
                    "readme": {
                        "en": "THis shows that having Asyncronous Update on will reduce maximum cook time.\n\nFind a folder with lots of files and turn on/off Include Subfolders and Asyncronous Update and look at the cook time.\n\n\n"
                    }
                },
                "2": {
                    "title": "mini movie folder bin",
                    "author": "",
                    "readme": {
                        "en": "Click any image to play movie and output current data. Pick one of your folders via the Folder  parameter.\n\nThe Folder DAT is set to contain only files, not folders, and only image or movie files.\n\nIt makes one component per file (mv1, mv2 ...). Each mv component is 16x9 and its content is fit to that aspect ratio.\n\nThe Container is set to arrange all components in a grid, best-fit to the space it's given (600x600).\n\nIt doesn't display mvmaster1 because its Display parameter is off and the replicated mv components have their Display turned on in replicator1_callbacks."
                    }
                }
            }
        },
        "infoDAT": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "handle",
                    "author": "",
                    "readme": {
                        "en": "The Info DAT is useful when using Direct X In and Direct X Out TOPs, in that you can get the Handle, as well as other useful information."
                    }
                },
                "1": {
                    "title": "video in",
                    "author": "",
                    "readme": {
                        "en": "In this example the Info DAT shows a list of possible video in devices."
                    }
                },
                "2": {
                    "title": "text",
                    "author": "",
                    "readme": {
                        "en": "Highlight the text in the field, and you can see your selection in the Info DAT."
                    }
                }
            }
        },
        "insertDAT": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "top row",
                    "author": "",
                    "readme": {
                        "en": "Put a row at top and fill each cell."
                    }
                },
                "1": {
                    "title": "row",
                    "author": "",
                    "readme": {
                        "en": "Here we insert a row."
                    }
                },
                "2": {
                    "title": "col",
                    "author": "",
                    "readme": {
                        "en": "Here we insert a column."
                    }
                },
                "3": {
                    "title": "fill each cell with index",
                    "author": "",
                    "readme": {
                        "en": "Here we insert a column."
                    }
                }
            }
        },
        "mergeDAT": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "text",
                    "author": "",
                    "readme": {
                        "en": "These two examples merge these two Text DATs by row and by column."
                    }
                },
                "1": {
                    "title": "collapse",
                    "author": "",
                    "readme": {
                        "en": "These examples demonstrate how to collapse either Rows or Columns."
                    }
                },
                "2": {
                    "title": "cell",
                    "author": "",
                    "readme": {
                        "en": "This example collapses all cells into one."
                    }
                },
                "3": {
                    "title": "selecting",
                    "author": "",
                    "readme": {
                        "en": "This example selects all tables whos names start with 'table' and then appends all of their rows into 1 table."
                    }
                }
            }
        },
        "midiinDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "midi messages per second",
                    "author": "",
                    "readme": {
                        "en": "You need a MIDI device attached.\n\nSee wiki and Dialogs -> MIDI Device Mapper\n\nFor every MIDI message, the constantCount goes up by 1. \n\nslope1 gives the number of MIDI messages per second, averaged over the last .2 seconds (the Filter CHOP filter width).\n\nMIDI In DAT is similar to MIDI Event CHOP, which doesn't need a setup in the MIDI Device Mapper."
                    }
                }
            }
        },
        "multitouchinDAT": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "simple events",
                    "author": "",
                    "readme": {
                        "en": "The DAT often gets fed right into a Render Pick DAT, but here the events are processed.\n\nAlso to operate 2D gadgets like Slider and Button components,  you don't need to include a Multi Touch In DAT - they operate automatically.\n\nSee also the Multitouch example in  the Palette.\n\nThe \"callbacks\" DAT attached to  mtouchin sets the \"text\" parameter of the Text TOP."
                    }
                },
                "1": {
                    "title": "pick instance",
                    "author": "",
                    "readme": {
                        "en": "Here we have a highly simplified example of a  Render Pick DAT. Here the Render Pick DAT is returning the number of the instance of the rendered geometry. This value is then passed from the DAT to a Text TOP.\n\nThis particular set-up is not ideal for a  project, but helps to illustrate the power of the Render Pick DAT. You might imagine a  situation where you used this method to change the color of the selected geometry in order to help a user see how they're interacting with a 3D scene."
                    }
                }
            }
        },
        "opexecuteDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "op execute",
                    "author": "",
                    "readme": {
                        "en": "This example is run everytime the operator box1 is changed.\n\nDepending on which functions you turn on in the OP Execute DAT, that could range from flag changes, wiring changes, name changes, etc.\n\nOpen your Textport and try changing different aspects of the operator. "
                    }
                }
            }
        },
        "opfindDAT": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "find type",
                    "author": "",
                    "readme": {
                        "en": "simply find OPs of a certain type.\n\nHere it finds all CHOP Execute DATs in this project starting from /."
                    }
                },
                "1": {
                    "title": "secondary table of nondefaults",
                    "author": "",
                    "readme": {
                        "en": "This looks for Transform TOPs where the tx, ty, sx and sy parameters are non-default and makes a table containing their current value in one row per parameter.\n\nNote that the OP Find DAT is creating one row per OP which is normal, but the callbacks script is creating, for each OP, a variable number of rows in gather1.\n\nThis illustrates how OP Find can build more complex data structures as it's crusing the hierarchy."
                    }
                },
                "2": {
                    "title": "opname",
                    "author": "",
                    "readme": {
                        "en": "Find based on operator name."
                    }
                },
                "3": {
                    "title": "search text",
                    "author": "",
                    "readme": {
                        "en": "Find read* Text DATs and select based on operator search string in text."
                    }
                },
                "4": {
                    "title": "find tags",
                    "author": "",
                    "readme": {
                        "en": "Find OPs with specific tags.  For each OP found, open up teh tags field by pressing the Show Tags button on the Parameter dialog."
                    }
                }
            }
        },
        "oscinDAT": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "sending messages",
                    "author": "",
                    "readme": {
                        "en": "This example sends the value of lfo1 when you click the Send button. \n\nThis message will be sent and recieved over OSC and UDP."
                    }
                },
                "1": {
                    "title": "osc",
                    "author": "",
                    "readme": {
                        "en": "Right click and Run 'test_sendOSC'.\n\nThis example will send sample data formatted in OSC."
                    }
                },
                "2": {
                    "title": "terminators",
                    "author": "",
                    "readme": {
                        "en": "This example sends different sample messages with different terminators via UDP."
                    }
                },
                "3": {
                    "title": "bytes",
                    "author": "",
                    "readme": {
                        "en": "This example sends different formatted bytes via UDP."
                    }
                }
            }
        },
        "oscoutDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "simple",
                    "author": "",
                    "readme": {
                        "en": "Go to OSC In DAT"
                    }
                }
            }
        },
        "panelexecuteDAT": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "mouse wheel and keys",
                    "author": "",
                    "readme": {
                        "en": "Panel values for mouse wheel and keys can  only be captured by Panel Execute DATs because they toggle the value back to 0 in a single frame.\n\nTurn Use Mouse Wheel on in a Panel COMP to enable the panel to handle the mouse wheel."
                    }
                },
                "1": {
                    "title": "button",
                    "author": "",
                    "readme": {
                        "en": "This example's function runs both when the button's state goes from On to Off, and when the state goes from Off to On.\n\nWhen the state goes on, the function writes a 1 into the table, and when it goes off, it writes a 0. "
                    }
                },
                "2": {
                    "title": "panel value",
                    "author": "",
                    "readme": {
                        "en": "Using the panelValue that is passed to the function when it is run allows us to figure out where the panel was last pressed.  Values are updated in a table."
                    }
                },
                "3": {
                    "title": "slider",
                    "author": "",
                    "readme": {
                        "en": "The panelValue variable is useful for getting slider values directly from a panel."
                    }
                },
                "4": {
                    "title": "to textport",
                    "author": "",
                    "readme": {
                        "en": "This example prints all the different functions as well as the panel's value directly to the Textport."
                    }
                }
            }
        },
        "parameterDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "all parmeter info",
                    "author": "",
                    "readme": {
                        "en": "select Built-in parameters and all columns to see full definition of the node's parameters."
                    }
                }
            }
        },
        "parameterexecuteDAT": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "two way",
                    "author": "",
                    "readme": {
                        "en": "Changing the slider will change the Period parameter of wave1 by panelexec1.\n\nChanging the Period parameter by hand will change the slider using .click() in parexec1."
                    }
                },
                "1": {
                    "title": "parameter exec",
                    "author": "",
                    "readme": {
                        "en": "This example will run everytime a parameter of box2 is changed.\n\nOpen the Dialogs -> Textport and operate the wiggleMe slider to see messages printed in the textport.\n\nThen try changing parameters,  adding expressions, and adding exports. "
                    }
                }
            }
        },
        "renderpickDAT": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "render pick",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates how to use a Render Pick DAT.\n\nClick on the rotating geometry to relocate the texture.\n\nGo inside the render_pick component, and you'll see the Panel CHOP feeding the Render Pick DAT the necessary UV coordinates needed to acquire mapu and mapv coordinates to translate the texture.\n\nSee also the Multitouch example in the Palette."
                    }
                },
                "1": {
                    "title": "render pick wip",
                    "author": "",
                    "readme": {
                        "en": "coming - better example.\n\nuntil then, on forum see Multitouch example in .tox forum category. or Palette/multiTouch"
                    }
                }
            }
        },
        "reorderDAT": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "reverse",
                    "author": "",
                    "readme": {
                        "en": "This reverses the order of the incoming DAT."
                    }
                },
                "1": {
                    "title": "specified order",
                    "author": "",
                    "readme": {
                        "en": "This example has had its rows reordered by name."
                    }
                },
                "2": {
                    "title": "replace",
                    "author": "",
                    "readme": {
                        "en": "This examples replaces row 1 with row 0, and does so by index."
                    }
                },
                "3": {
                    "title": "specified order index",
                    "author": "",
                    "readme": {
                        "en": "This functions similarly to specified order by name, except that you order your input by index."
                    }
                },
                "4": {
                    "title": "repeating",
                    "author": "",
                    "readme": {
                        "en": "You can repeat indices at free will by entering them more than once into the 'Order' field."
                    }
                }
            }
        },
        "scriptDAT": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "common",
                    "author": "",
                    "readme": {
                        "en": "Common things to create tables, modify, and add rows and columns that are composed from other cells."
                    }
                },
                "1": {
                    "title": "copy input and iterate rows",
                    "author": "",
                    "readme": {
                        "en": "Copy the input table and then iterate over the rows."
                    }
                },
                "2": {
                    "title": "iterate input rows",
                    "author": "",
                    "readme": {
                        "en": "In the first case, for each row of the input, create a new row for the output. In the second case row 1 to 5, column 'col1' is summed.\n\nThe first uses:\n\tfor r in range(1,table.numRows):\n\t\n\tr is a row integer to access the input table. \n\nThe second uses:\n\tfor row in table.rows():\n\t\n\trow is a list of cell in a row.\n\t\nThe first way of going through rows is more flexible because you can use any range of rows - it's starting at row 1 in this case. It's also better as you can access the column by name, which you can't in the second methof,"
                    }
                },
                "3": {
                    "title": "random",
                    "author": "",
                    "readme": {
                        "en": "Right click and \"Force Cook\" the Script DAT to generate more random numbers.\n\nThis example uses a Custom Parameter Integer slider to generate the number of rows."
                    }
                },
                "4": {
                    "title": "replace",
                    "author": "",
                    "readme": {
                        "en": "This example will take two inputs  and replace any rows in A with those found in B. "
                    }
                },
                "5": {
                    "title": "for all cells",
                    "author": "",
                    "readme": {
                        "en": "The first Script DAT iterates over all cells and replaces each string with its length.\n\nThen second Script DAT iterates over all cells of the first input and compares with the corresponding cell of the second input. "
                    }
                },
                "6": {
                    "title": "exclude",
                    "author": "",
                    "readme": {
                        "en": "This example appends all the rows in the input except rows containing a word in the Custom Parameter named 'Exclude' on the  'My Parameters' page in the Script DAT.\n\nThe 'Exclude' custom parameter takes a string as input, which in this case is a comma-separated list of words to exclude."
                    }
                },
                "7": {
                    "title": "shuffle",
                    "author": "",
                    "readme": {
                        "en": "This example shuffles the contents of each cell using\nthe seed value found in the 'Seed' Custom Parameter on\nthe 'Custom1' Parameter Page."
                    }
                }
            }
        },
        "selectDAT": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "",
                    "readme": {
                        "en": "You can select by wiring in, or using the parameter which lets you select from anywhere. "
                    }
                },
                "1": {
                    "title": "all",
                    "author": "",
                    "readme": {
                        "en": "This example selects all of the table. "
                    }
                },
                "2": {
                    "title": "index",
                    "author": "",
                    "readme": {
                        "en": "You can pick out specific regions you'd like to select by index."
                    }
                },
                "3": {
                    "title": "name",
                    "author": "",
                    "readme": {
                        "en": "You can pick out specific regions you'd like to select by name."
                    }
                },
                "4": {
                    "title": "values",
                    "author": "",
                    "readme": {
                        "en": "You can pick out specific regions you'd like to select by value."
                    }
                },
                "5": {
                    "title": "non empty",
                    "author": "",
                    "readme": {
                        "en": "Using the pattern '?*' you can select all non-empty cells."
                    }
                },
                "6": {
                    "title": "network",
                    "author": "",
                    "readme": {
                        "en": "Select DATs become even more useful when you need to use information in another part of your network, as it saves extra wiring that would otherwise make a mess."
                    }
                }
            }
        },
        "serialDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "serial",
                    "author": "",
                    "readme": {
                        "en": "This examples take a serial input and changes it to CHOP values.\n\nThis example specifically had two values input simultaneously, and using a Convert DAT to split the values at every period, we're able to get an integer representing each value."
                    }
                }
            }
        },
        "soptoDAT": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "roffset points with table",
                    "author": "",
                    "readme": {
                        "en": "This example uses a SOP to DAT to offset points of the SOP with values in a table, one row per point in the SOP. "
                    }
                },
                "1": {
                    "title": "replace points",
                    "author": "",
                    "readme": {
                        "en": "This example uses a SOP to DAT to randomize the life span of the particle system.\n\nUsing all the point information from the SOP to DAT, we isolate life(1), and use an Evaluate DAT to add noise to each individual point position. We then use a DAT to SOP to apply the new life span values. "
                    }
                }
            }
        },
        "sortDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "sort",
                    "author": "",
                    "readme": {
                        "en": "To sort a table so that Column 1 is sorted first, and then column2 is sorted second etc, chain sort DATs so that the first DAT sort the last column, second DAT sort the second last column, etc, and the last DAT sorts the first column.\n\nAlphaNumeric sort will sort a1, a2, a11 correctly,  treating the digits as number, where as Alphabetical will sort it into a1, a11, a2.\n\nNumeric sorts will treat all non digits as 0."
                    }
                }
            }
        },
        "substituteDAT": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "substitute",
                    "author": "",
                    "readme": {
                        "en": "A simple substitute example changing a symbol for TouchDesigner."
                    }
                },
                "1": {
                    "title": "numbers",
                    "author": "",
                    "readme": {
                        "en": "A simple example changing 1 2 3 to 3 4 5."
                    }
                },
                "2": {
                    "title": "scope",
                    "author": "",
                    "readme": {
                        "en": "This example substitutes the letter 'e' for the letter 'a', but its scope is only set to the second row of the table. "
                    }
                },
                "3": {
                    "title": "case sensitive",
                    "author": "",
                    "readme": {
                        "en": "This example is set to replace 'A' with the letter 'e'. With case-sensitivity On, this will only affect the upper case A, whereas without case-sensitivity, the whole first column would be changed to 'e'."
                    }
                },
                "4": {
                    "title": "replace path",
                    "author": "",
                    "readme": {
                        "en": "THis changes the start of a path name to another path, like you would do when moving media to another location.\n\nNOTE: See also the Evaluate DAT, and also python has plento of string manipulation tools."
                    }
                },
                "5": {
                    "title": "second input",
                    "author": "raganmd",
                    "readme": {
                        "en": "When this wasn't documented, somehow Mathew Ragan found out this is possible - put a table in the second inpt that lets you do several substitutions.\n\nMatthew Ragan"
                    }
                }
            }
        },
        "switchDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "switch",
                    "author": "",
                    "readme": {
                        "en": "The Count CHOP that is triggered by the LFO, is changing the index of the Switch DAT, which selects a different input to pass as  an output."
                    }
                }
            }
        },
        "tableDAT": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "table",
                    "author": "",
                    "readme": {
                        "en": "You can put values into individual cells of a table by making its viewer active (clicking the plus in the bottom right corner of the operator), and clicking in a cell."
                    }
                },
                "1": {
                    "title": "size",
                    "author": "",
                    "readme": {
                        "en": "You can set your  exact table dimensions ahead of time via the 'Exact Dimension' parameter."
                    }
                },
                "2": {
                    "title": "run script",
                    "author": "",
                    "readme": {
                        "en": "Right click and 'Run' these Text DATs"
                    }
                }
            }
        },
        "tcpipDAT": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "terminators",
                    "author": "",
                    "readme": {
                        "en": "Right click and Run 'test_send'.\n\nIt will send some strings with different terminators through 'tcpip2', the server, to 'tcpip1', the client.\n\n"
                    }
                },
                "1": {
                    "title": "bytes",
                    "author": "",
                    "readme": {
                        "en": "Right click and Run 'test_send1'.\n\nThis example sends bytes in a few different ways, including using the Python struct module."
                    }
                }
            }
        },
        "textDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "run",
                    "author": "",
                    "readme": {
                        "en": "Right click and 'Run' these Text DATs"
                    }
                }
            }
        },
        "transposeDAT": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "column to row",
                    "author": "",
                    "readme": {
                        "en": "Changing a column to a row."
                    }
                },
                "1": {
                    "title": "row to column",
                    "author": "",
                    "readme": {
                        "en": "Changing a row to a column."
                    }
                },
                "2": {
                    "title": "transpose table",
                    "author": "",
                    "readme": {
                        "en": "If you transpose a table, you are flipping the contents."
                    }
                }
            }
        },
        "udpinDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "udpin",
                    "author": "",
                    "readme": {
                        "en": "Go to OSC In DAT"
                    }
                }
            }
        },
        "udpoutDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "simple",
                    "author": "",
                    "readme": {
                        "en": "Go to OSC In DAT"
                    }
                }
            }
        },
        "webDAT": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "web",
                    "author": "",
                    "readme": {
                        "en": "Click the Fetch parameter in the operator 'web_derivative', to pull down the source code  of the Derivative website."
                    }
                },
                "1": {
                    "title": "weather",
                    "author": "",
                    "readme": {
                        "en": "This example is able to get raw weather data about your region from Yahoo.com. \n\nTo do so, edit the last  5 digits of URL to your zip code then hit 'Submit and Fetch'. "
                    }
                },
                "2": {
                    "title": "bbc news image",
                    "author": "",
                    "readme": {
                        "en": "This example gets the first images of a BBC news feed. (NOTE it returns each thumbnail at 2 resolutions) "
                    }
                },
                "3": {
                    "title": "images from web",
                    "author": "",
                    "readme": {
                        "en": "This example gets images from a web page."
                    }
                }
            }
        },
        "webclientDAT": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "web client",
                    "author": "",
                    "readme": {
                        "en": "Click the Request parameter in the operator 'webclient_derivative', to pull down the source code of the Derivative website."
                    }
                },
                "1": {
                    "title": "derivative docs",
                    "author": "",
                    "readme": {
                        "en": "In this example the url encoded attribute\nfor the url is passed in as a name/value pair \nthrough the second input of the Web Client DAT.\n\nIt's equivalent to \n\nhttps://docs.derivative.ca/index.php?title=Web_Client_DAT\n\nClick Request.\n\nTurn Active on "
                    }
                },
                "2": {
                    "title": "nasa on the station news images",
                    "author": "",
                    "readme": {
                        "en": "This example fetches an rss xml feed from nasa, parses the xml data and extracts an image url as well as a headline using the onResponse callback of the Web Client DAT."
                    }
                },
                "3": {
                    "title": "images from web",
                    "author": "",
                    "readme": {
                        "en": "This example gets images from a web page.\n\nPress the Request button.\n\ndata is the data text coming from the web page, decodes with data.decode as a text string.\n\n\"re\" is a python library that deals with regular expressions.\n\nIt creates a list of strings that match the pattern, looking for strings that have \"img*src\" tags in them, looking for lines like this:\n\n<img class=\"svg-img\" src=\"https://derivative.ca/sites/all/themes/derivative2017/logo.svg\"\n\nimages is a list of lists, and img's second element is the path to the image file on the internet.\n\n\n\n\n\n\n"
                    }
                }
            }
        },
        "webserverDAT": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "server socket update",
                    "author": "",
                    "readme": {
                        "en": "connect to the server via port 9980.\n\nthe webpage will display the same data as the showCooks component and update the graph\n\nThe website connects to the server and pulls all required libraries via the libs component. \n\nAlso a websocket connection is estabished which allows the webserver to send data to the webpage. The webpage also communicates back to the server via the \"Update Frequency\" radio buttons."
                    }
                },
                "1": {
                    "title": "return images",
                    "author": "",
                    "readme": {
                        "en": "connect to the server via port 9980.\n\nthe server will create a random image\nand send it to the client."
                    }
                },
                "2": {
                    "title": "authentication",
                    "author": "",
                    "readme": {
                        "en": "the server expects basic authentication.\n\nturn on Basic Authentication in the webclient to retrieve the installation folder of TouchDesigner."
                    }
                }
            }
        },
        "websocketDAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "websocket",
                    "author": "",
                    "readme": {
                        "en": "Right click and run 'runMe'.\n\nThis example sends 2 messages out of websocket1, to  echo.websocket.org, which will mirror those same messages back to the Websocket DAT.\n\nThese messages get written to 'results'."
                    }
                }
            }
        },
        "xmlDAT": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "parsing",
                    "author": "",
                    "readme": {
                        "en": "This example pulls raw weather data from Yahoo.com, and parses out the 5 day forecast and city into easily legible tables.\n\nTo use, change the last 5 digits in the URL of web2 to your zip code, then click 'Submit and Fetch'.\n\nNote how the forecast table is then turned into CHOP channels. These channels can be used easily for data visualizations. "
                    }
                },
                "1": {
                    "title": "xml",
                    "author": "",
                    "readme": {
                        "en": "This example parses this dummy XML filled with information about books into a legible and organized table. "
                    }
                }
            }
        }
    },
    "MAT": {
        "glslMAT": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "GLSL from phong or PBR",
                    "author": "",
                    "readme": {
                        "en": "A basic GLSL shader can be created by setting up a Phong or PBR material, and outputting the equivalen shader by pulsing the Output Shader... parameter."
                    }
                },
                "1": {
                    "title": "GLSL instance",
                    "author": "",
                    "readme": {
                        "en": "texturing:\n\n1. The textures stay in their original format (2D), less memory, less work to build the 3D texture\n\n2. The textures can be different resolutions\n\n3. The textures can be changing (such as be movies) without a performance penalty caused by rebuilding the 3D texture\n\nNotice the new usage of vVert. \n\ninstanceTextureHandle in the shaders, as well as the Instance Textures parameter being filled in on the Geometry COMP \u2018Instance 2\u2019 page."
                    }
                },
                "2": {
                    "title": "geometry shader",
                    "author": "malcolm",
                    "readme": {
                        "en": "texturing:\n\n1. The textures stay in their original format (2D), less memory, less work to build the 3D texture\n\n2. The textures can be different resolutions\n\n3. The textures can be changing (such as be movies) without a performance penalty caused by rebuilding the 3D texture\n\nNotice the new usage of vVert. \n\ninstanceTextureHandle in the shaders, as well as the Instance Textures parameter being filled in on the Geometry COMP \u2018Instance 2\u2019 page."
                    }
                },
                "3": {
                    "title": "GLSL #include",
                    "author": "malcolm",
                    "readme": {
                        "en": "include code from other DATs"
                    }
                }
            }
        },
        "lineMAT": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "basic lines",
                    "author": "greg",
                    "readme": {
                        "en": "Line MAT gives solid line rendering. This is a basic render setup.\n\nPlay with the Line MAT parameters on Setup and Line pages, like width near/far, colors, cap types,  \n\nTranslate geo1 in Z for depth effect.\n\nRendered line widths are not intended to be depth-correct: this gives more user control. (set Depth Interpolation Model to Inverse Distange to get depth-correct)\n\nLights have no effect. Colors are based on near-far colors and points' distance from camera.\n\nMost SOP viewers are set to Wireframe (w).\n\n\nThings to try:\n\n- near-far color/width tapering controls\n- end caps\n- joints\n- Points, Vectors\n\n"
                    }
                },
                "1": {
                    "title": "color and end caps",
                    "author": "greg",
                    "readme": {
                        "en": "Orientation-independent line widths, with endcap and joint controls.\n\nSeveral SOP types rendered with the Line Material and displayed with sopRender from the Palette to tumble/zoom.\n\nDrag-drop SOPs to toRender (easier than wiring, it's a Select SOP).\n\ntoRender's viewer is set to Wireframe (w).\n\nflick sopRender to autoRotate.\n\nThings to try:\n\n- near-far color/width tapering controls\n- end caps\n- joints\n- Points, Vectors\n\n"
                    }
                },
                "2": {
                    "title": "animate width",
                    "author": "greg",
                    "readme": {
                        "en": "SOP has 'width' attribute, animated.\n\nPlay with Line Width Bias, Steepness, Linarize, and Near-Far distances.\n\nTurn the Points on.\n"
                    }
                },
                "3": {
                    "title": "instance CHOP samples",
                    "author": "greg",
                    "readme": {
                        "en": "A few hundred thousand samples are created in CHOPs, then passed to the Geometry COMP for instancing.\n\ngeo1 has convert2 for display, a SOP with one point, and one Particle primitive containing the point.\n\nThe point has to be part of a particle system to render by the Line MAT (or any MAT) as a single point (the SOP cannot be just one point with no primitives, it needs a primitive, and the Convert SOP converts it to a Particle System primitive).\n"
                    }
                },
                "4": {
                    "title": "table, line width, double-render",
                    "author": "greg",
                    "readme": {
                        "en": "Lines are defined in a DAT. passed to Add SOP where points are specified into a polygon. \n\ngeo1 is Line Mat, geo2 is same geometty, but with default Phone MAT.\n\ngeo1 is at z = -.1 to make sure it gets rendered in background."
                    }
                },
                "5": {
                    "title": "vectors from TOPs",
                    "author": "",
                    "readme": {
                        "en": "Line MAT example drawing vectors.\n\nVectors are defined in TOPs feeding geo_vector.\n\nlevel1 adding alpha by setting Low A to 1.\n\nlevel1 looks smoother than render1 because Viewer Smoothness menu set to Mipmap Pixels."
                    }
                }
            }
        },
        "pbrMAT": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "eric",
                    "readme": {
                        "en": "The individual textures are selected from the Substance TOP and added to Substance TOP parameter under the \"Maps\" page on the PBR MAT.\n\npbr1 is the Material of geo1. Inside the Geometry COMP has a SOP with tangent, normal, and uv attributes.\n\nIn the scene there is a point light and an environment light with moviefilein1 as the environment map. The environment light is required for ambient occlusion to be visible.\n"
                    }
                },
                "1": {
                    "title": "separate substance",
                    "author": "eric",
                    "readme": {
                        "en": "In this case the individual textures are selected from the Substance Designer package and added to the respective map parameter under the \"Maps\" page on the PBR MAT.\n\nbasecolor is modified before being sent to the PBR MAT."
                    }
                },
                "2": {
                    "title": "multi-buffer render",
                    "author": "eric",
                    "readme": {
                        "en": "pbr1 is the material of geo1, and two instances are created of geo.  \n\nSubstance TOP is added to Substance TOP parameter on PBR MAT (pbr1). This automatically unpacks all the textures in the package and assigns them to their respective maps. Overriding the Substance TOP is done by filling in a map parameter. The Normal Map in the Substance TOP is being overriden by normal1 in the Normal Map parameter.\n\npbr1 has an emit map of moviefilein1 (banana). This is illustrated by the continuous dimming of the point lights. When they are both fully dimmed the banana is still visible, since it is emitting its own light. pbr2 does not have an emit map so it is completely black when the lights are fully dimmed.\n\npbr1 has a rim light, which is also most visible when the two point lights are dimmed.\n\npbr1 has 5 additional maps put into the color buffers of the Render TOP (done on the Advanced Page of PBR MAT: roughness, metallic, ambient occlusion, normal, emit). Color buffers can be selected using the Render Select TOP and the color buffer's index. Index is based on the parameter on the Advanced page of PBR MAT. Color buffer size is increased using the parameter on the Render TOP. pbr2 does not have any additional color buffers on the Advanced page so it is not visible in those 5 Render Select TOPs.\n"
                    }
                },
                "3": {
                    "title": "parallex height map",
                    "author": "eric",
                    "readme": {
                        "en": "This example demonstrates the difference between two PBR materials, one using a height map, and one not.\n\nThe sphere on the left of the render is not using a height map, while the sphere on the right is.\n\nThe individual textures are selected from the Substance Designer package and added to the respective map parameter under the \"Maps\" page on both PBR MATs.\n\nno_height and using_height PBR MAT are the materials of no_height_geo and using_height_geo respectively."
                    }
                }
            }
        },
        "phongMAT": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "Phong basic",
                    "author": "eric",
                    "readme": {
                        "en": "Select base color and normal from a Substance TOP and add them to Color map and Normal map respectively. \n\nChange the specular lighting to be yellow instead. Add an environment map (moviefilein1) to phong1 and rotate it to the left side."
                    }
                }
            }
        }
    },
    "SOP": {
        "addSOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "add triangle",
                    "author": "",
                    "readme": {
                        "en": "Polygons in clockwise order."
                    }
                },
                "1": {
                    "title": "add",
                    "author": "",
                    "readme": {
                        "en": "In this example we add a second box to the scene that contains a sphere."
                    }
                },
                "2": {
                    "title": "points",
                    "author": "",
                    "readme": {
                        "en": "In this example we manually added 4 points and created a square."
                    }
                },
                "3": {
                    "title": "delete geo",
                    "author": "",
                    "readme": {
                        "en": "The Add SOP has a useful function in that it can delete the geometry of an input while keeping the points for later use."
                    }
                }
            }
        },
        "alignSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "align",
                    "author": "",
                    "readme": {
                        "en": "TBD"
                    }
                }
            }
        },
        "armSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "arm",
                    "author": "",
                    "readme": {
                        "en": "This is a simple example of an arm created with the Arm SOP. "
                    }
                }
            }
        },
        "basisSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "knots",
                    "author": "",
                    "readme": {
                        "en": "This example re-parameterizes the knot sequence manually by input values. "
                    }
                }
            }
        },
        "blendSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "blend",
                    "author": "",
                    "readme": {
                        "en": "The Blend SOP can blend between two inputs.\n\nHere we blend between two different sized boxes."
                    }
                },
                "1": {
                    "title": "blend1",
                    "author": "",
                    "readme": {
                        "en": "The Blend SOP is unique in that you can individual weight how much each input effects the blend.\n\nHere we've individually weighted the various inputs to create our output geometry.\n\nWhen Diferncing is On, the Blend  Weight of Input 0 has no effect. "
                    }
                }
            }
        },
        "booleanSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "boolean types",
                    "author": "bLackburst",
                    "readme": {
                        "en": "The Boolean SOP lets you use one SOP to add to subtract from another. \n\nNOTE: Both SOPs muse be polygonal and must be closed, eg. no open tubes etc.\n\nJames Hunter"
                    }
                }
            }
        },
        "boxSOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "size",
                    "author": "",
                    "readme": {
                        "en": "These examples show different ways of using the Size parameter to change the shape of a Box."
                    }
                },
                "1": {
                    "title": "center",
                    "author": "",
                    "readme": {
                        "en": "The Center parameters allow you to translate the Box in 3D space."
                    }
                },
                "2": {
                    "title": "input",
                    "author": "",
                    "readme": {
                        "en": "The Box SOP will create a Box around the input  geometry."
                    }
                },
                "3": {
                    "title": "consolidate and compute",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates that you can consolidate the corner points of the Box and the compute correct normals for each primitive."
                    }
                },
                "4": {
                    "title": "division",
                    "author": "",
                    "readme": {
                        "en": "These examples divide the Box SOP by the assigned values in the Division parameter.\n\nYou can also create enforcement bars for the geometry when you create divisions."
                    }
                },
                "5": {
                    "title": "texture",
                    "author": "",
                    "readme": {
                        "en": "The Box SOP has a handy feature in that you can assign your texture UV upon creation."
                    }
                }
            }
        },
        "capSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "round cap",
                    "author": "",
                    "readme": {
                        "en": "This example places a rounded end cap on the input geometry."
                    }
                },
                "1": {
                    "title": "faceted",
                    "author": "",
                    "readme": {
                        "en": "This example places a faceted cap on the input geometry."
                    }
                }
            }
        },
        "carveSOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "carve",
                    "author": "",
                    "readme": {
                        "en": "Here we've carved out two of the sides of the rectangle using the First U and Second U  parameters."
                    }
                },
                "1": {
                    "title": "breakpoints",
                    "author": "",
                    "readme": {
                        "en": "Using breakpoints means that the Carve SOP will be applied at breakpoints for for curves, and vertices for polygons, as opposed  to exactly where your carve points are. "
                    }
                },
                "2": {
                    "title": "inside outside",
                    "author": "",
                    "readme": {
                        "en": "These examples show the difference between the Keep Inside and Keep Outside "
                    }
                },
                "3": {
                    "title": "isoparametric profile",
                    "author": "",
                    "readme": {
                        "en": "You can extract the 2D or 3D isoparametric profile of your geometry using the Carve SOP."
                    }
                },
                "4": {
                    "title": "carve sphere",
                    "author": "",
                    "readme": {
                        "en": "These two examples feature some more complex geometry being carved out of a sphere."
                    }
                },
                "5": {
                    "title": "points",
                    "author": "",
                    "readme": {
                        "en": "The Carve SOP can also extract the points specificed, instead of extracting a cross section."
                    }
                }
            }
        },
        "choptoSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "",
                    "readme": {
                        "en": "Basic CHOP to SOP. You need to match channel names to SOP attributes."
                    }
                },
                "1": {
                    "title": "particles",
                    "author": "",
                    "readme": {
                        "en": "This example uses a SOP to CHOP to get all the point positions of a circle. Noise is applied to each of the point positions, then using a CHOP to SOP, we apply these new values to the Normals.\n\nThis allows us to control the direction in which the particles in particle1 are emitted."
                    }
                },
                "2": {
                    "title": "chop to sop rings",
                    "author": "",
                    "readme": {
                        "en": "This is a more advanced example of using a CHOP to SOP.\n\nIn the example a few SOP to CHOPs are used to  gather data on the points and normals. After modulating, the point positions, along  with newly created RGBA values are added back to the geometry using a CHOP to SOP. "
                    }
                }
            }
        },
        "circleSOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "transform",
                    "author": "",
                    "readme": {
                        "en": "These examples explore the the circle's Radius and Center parameters."
                    }
                },
                "1": {
                    "title": "divisions",
                    "author": "",
                    "readme": {
                        "en": "This example controls the divisions of a polygon circle."
                    }
                },
                "2": {
                    "title": "closed arc angle",
                    "author": "",
                    "readme": {
                        "en": "This is an example of a closed arc type, that starts at angle 180 and ends at 360."
                    }
                },
                "3": {
                    "title": "sliced",
                    "author": "",
                    "readme": {
                        "en": "This is similar to a closed arc except that every point is connected to the center of the circle."
                    }
                },
                "4": {
                    "title": "open arc",
                    "author": "",
                    "readme": {
                        "en": "Open arc types don't close themselves."
                    }
                }
            }
        },
        "clipSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "clip",
                    "author": "",
                    "readme": {
                        "en": "These examples show how the Clip SOP cuts the geometry where at the animated plane."
                    }
                }
            }
        },
        "convertSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "to polygon",
                    "author": "",
                    "readme": {
                        "en": "This example changes the Mesh sphere to a polygon sphere."
                    }
                },
                "1": {
                    "title": "to circles",
                    "author": "",
                    "readme": {
                        "en": "This example changes the faces of the box to circles."
                    }
                },
                "2": {
                    "title": "to bezier",
                    "author": "",
                    "readme": {
                        "en": "This example shows how each triangle of the polygon sphere was changed to a Bezier surface."
                    }
                }
            }
        },
        "copySOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "transform",
                    "author": "",
                    "readme": {
                        "en": "With Transform Cumulative set to On, the transform values that each copy inherit are cumulative."
                    }
                },
                "1": {
                    "title": "input",
                    "author": "",
                    "readme": {
                        "en": "This example makes a copy of the Copy SOPs input 1 at every point of input 2."
                    }
                },
                "2": {
                    "title": "stamping",
                    "author": "",
                    "readme": {
                        "en": "You can stamp any parameter as long as the parameter is upstream.\n\nIn these example we use the number of copies to change a parameter upstream of the Copy SOP, in this case transform1 and circle2. \n\nUse the expression fetchStamp('name', devaultval) and a downstream Copy SOP will evaluate it and use it for each copy it makes."
                    }
                }
            }
        },
        "creepSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "creep",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates how to use a Creep SOP to animate the first input's geometry along the surface of the second input's geometry.\n\n"
                    }
                }
            }
        },
        "dattoSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "sop to dat to sop",
                    "author": "",
                    "readme": {
                        "en": "Three DATs are needed for DAT to SOP: \n\n1) For points that hold the XYZ positions and other attributes like Texture UV and point color.\n\n2) For Vertices that specify other attributes that may also include Texture UV.\n\n3) For the Primitives that specify which points are connected for each polygon or other primitive type."
                    }
                },
                "1": {
                    "title": "build",
                    "author": "",
                    "readme": {
                        "en": "The first example creates the squares using all the data in the tables.\n\nThe second example uses all of the information about the squares but then closes them on it's own. "
                    }
                },
                "2": {
                    "title": "points",
                    "author": "",
                    "readme": {
                        "en": "You can also use a DAT to SOP to edit specific values of the input, in this case we changes the point positions."
                    }
                }
            }
        },
        "deleteSOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "prim pattern",
                    "author": "",
                    "readme": {
                        "en": "This example deletes primitives by pattern. "
                    }
                },
                "1": {
                    "title": "point pattern",
                    "author": "",
                    "readme": {
                        "en": "This example deletes points by pattern."
                    }
                },
                "2": {
                    "title": "range",
                    "author": "",
                    "readme": {
                        "en": "This example deletes primitives by range.\n\nThe ranges start and end values of 0 and 6, include all the  box's primitives.\n\nAnd selecting 1 of 2, means that half of the primitives between primitive 0 and 6 will be deleted."
                    }
                },
                "3": {
                    "title": "range1",
                    "author": "",
                    "readme": {
                        "en": "This is another example of deleting by range.\n\nIn this example 1 of every 5 primitives between primitive 0 and 361 are deleted."
                    }
                },
                "4": {
                    "title": "bounding box",
                    "author": "",
                    "readme": {
                        "en": "You can use Delete SOP to delete by bounding box.\n\nThis means that everything that falls inside the box will be deleted."
                    }
                },
                "5": {
                    "title": "bounding box1",
                    "author": "",
                    "readme": {
                        "en": "This is another example of deleting by bounding box.\n\nIn this example the bounding box's movement is animated."
                    }
                },
                "6": {
                    "title": "spread angle",
                    "author": "",
                    "readme": {
                        "en": "You can delete primitives by spread angle.\n\nThis compares the angle of each normal against the direction you specify using the Direction values, and i the angle is greater than the Spread Angle value, that primitive will be deleted."
                    }
                },
                "7": {
                    "title": "spread angle1",
                    "author": "",
                    "readme": {
                        "en": "This is another example of deleting by spread angle.\n\nYou can see in this example the spread angle deletes all the peaks from the simulated geography."
                    }
                }
            }
        },
        "extrudeSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "extrude",
                    "author": "",
                    "readme": {
                        "en": "This example creates 3D extruded text using the Extrude SOP.\n\nThe Attribute Create SOP is used at the end to compute the normals."
                    }
                }
            }
        },
        "facetSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "corner points",
                    "author": "",
                    "readme": {
                        "en": "This example consolidates corner points on this sphere."
                    }
                },
                "1": {
                    "title": "unique points",
                    "author": "",
                    "readme": {
                        "en": "This example creates a series of unique points at corners where different primitives meet.\n\nNotice in sphere2 where there is a single point at each corner, whereas in the viewer of the Facet SOP, you can see multiple points at each corner where primitives meet."
                    }
                },
                "2": {
                    "title": "compute normals",
                    "author": "",
                    "readme": {
                        "en": "This example computes the normals of the sphere after creating unique points, allowing you to more clearly see the effect of creating unique points. In the Primitive SOP, each of the newly made primitive is scaled down to create the 3D pattern."
                    }
                }
            }
        },
        "fileinSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "file in",
                    "author": "",
                    "readme": {
                        "en": "You can import a variety of 3D geometry from other 3D suites using the File In SOP."
                    }
                },
                "1": {
                    "title": "normals",
                    "author": "",
                    "readme": {
                        "en": "If your imported geometry is missing normals, you can compute them in the File In SOP."
                    }
                }
            }
        },
        "filletSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "fillet",
                    "author": "",
                    "readme": {
                        "en": "This example shows how a Fillet SOP can create a surface inbetween two curves or polygons without affecting the input geometry."
                    }
                }
            }
        },
        "fitSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "approximation",
                    "author": "",
                    "readme": {
                        "en": "These two examples  use the approximation method to fit Test to the data points, without having to touch all of them.\n\nThis is useful for leaning down very complex data sets."
                    }
                },
                "1": {
                    "title": "tolerance and smoothness",
                    "author": "",
                    "readme": {
                        "en": "The Tolerance parameter is the precision factor for the Approximation method. The higher the value the less amount of vertices are made during the fit.\n\nAdditional smoothing can  be applied via the Smoothness parameter."
                    }
                },
                "2": {
                    "title": "interpolation",
                    "author": "",
                    "readme": {
                        "en": "This example uses the interpolation method to fit Test to the data points, making sure to touch every point.\n\nThis is generally more useful on smaller data sets, as it can sometimes produce more control vertices than originally input."
                    }
                }
            }
        },
        "forceSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "force",
                    "author": "",
                    "readme": {
                        "en": "Using the Force SOP you can apply different kinds of forces to particle systems.\n\nIn this example, a vortex force is applied for as long as you hold down the 'Hold for Force' button. "
                    }
                }
            }
        },
        "fractalSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "fractal",
                    "author": "",
                    "readme": {
                        "en": "This example creates divisions along the input surface."
                    }
                },
                "1": {
                    "title": "terrain",
                    "author": "",
                    "readme": {
                        "en": "The Fractal SOP is useful when creating terrain like geometry."
                    }
                }
            }
        },
        "gridSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "grid",
                    "author": "",
                    "readme": {
                        "en": "You can see the difference between the grid and the rectangle when you look at their wireframes."
                    }
                }
            }
        },
        "groupSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "group, merge, transform",
                    "author": "bLackburst",
                    "readme": {
                        "en": "The Group SOP gives you the ability to limit the \"scope\" of downstream SOPs without forking them off individually. \n\nFor example, here we create a group for the sphere, box and torus individually. \n\nThen we can affect each in isolation, despite being in the same SOP chain.\n\nNote the Group selection at the top of many SOPs.\n\nJames Hunter"
                    }
                },
                "1": {
                    "title": "group primitives",
                    "author": "",
                    "readme": {
                        "en": "Creating a group of primitives within one SOP, named \"top\".\n\nTransforming just that group."
                    }
                }
            }
        },
        "holeSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "hole",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates how you can create and fill holes easily with the Hole SOP."
                    }
                }
            }
        },
        "isosurfaceSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "iso surface",
                    "author": "",
                    "readme": {
                        "en": "These are a few examples of how Iso Surfaces are made using Implicit Functions."
                    }
                }
            }
        },
        "joinSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "join",
                    "author": "",
                    "readme": {
                        "en": "The Join SOP takes the input geometry, which contains various lines in this case, and joins them together smoothly."
                    }
                }
            }
        },
        "jointSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "joint",
                    "author": "",
                    "readme": {
                        "en": "This example shows how the Joint SOP creates circles between a pair of input circles.\n\nThis can be used in the creation of circle-based skeletons."
                    }
                }
            }
        },
        "latticeSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "lattice",
                    "author": "",
                    "readme": {
                        "en": "This example animates the deformation of the TEST geometry with the twisted grid.\n\nNotice how the Lattice SOP is set up as it takes specific inputs."
                    }
                }
            }
        },
        "limitSOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "limit",
                    "author": "",
                    "readme": {
                        "en": "At its simplest, the Limit SOP creates geometry from CHOP channels.\n\nHere, we've made a table with some very simple point positions, which  are then converted to CHOP channels, and fed to the Limit SOP."
                    }
                },
                "1": {
                    "title": "sop to",
                    "author": "",
                    "readme": {
                        "en": "In this example we created out CHOP channels using a SOP to CHOP, then converted our channels back to a SOP using the Limit SOP.\n\nThe difference is that the Limit SOP uses a single Polygonal Line to connect all the points of the Grid."
                    }
                },
                "2": {
                    "title": "circle",
                    "author": "",
                    "readme": {
                        "en": "Directly to the right, we use two sine wave LFOs to create two channels needed to draw a circle using the Limit SOP."
                    }
                },
                "3": {
                    "title": "circle2",
                    "author": "",
                    "readme": {
                        "en": "Here we modulate our original sine waves with faster sine waves.\n\nWhen we use the Limit SOP with these channels, we see a more interesting pattern with swirls."
                    }
                },
                "4": {
                    "title": "circle 3",
                    "author": "",
                    "readme": {
                        "en": "If we use a triangle wave to modulate both of the previous examples channels, we can create a more interesting pattern that becomes larger and smaller as the triangle wave increases and decreases.\n\nOne of the two SOPs at the end have Adaptive Homing off."
                    }
                },
                "5": {
                    "title": "output",
                    "author": "",
                    "readme": {
                        "en": "The Limit SOP has different output options.\n\nThese three examples show three of the common examples used to draw some Sparse noise."
                    }
                }
            }
        },
        "lineSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "line",
                    "author": "",
                    "readme": {
                        "en": "You can create lines by assigning co-ordinates to the start and end of the line (Point A and Point B)."
                    }
                },
                "1": {
                    "title": "points",
                    "author": "",
                    "readme": {
                        "en": "You can add more points to your line using the Number of Points parameter."
                    }
                }
            }
        },
        "linethickSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "line thick",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates how the Line Thick SOP can extrude a surface from a curved line."
                    }
                }
            }
        },
        "lsystemSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "L system",
                    "author": "",
                    "readme": {
                        "en": "L-Systems can be quite complicated but can create very organic geometry.\n\nThis is a very basic example that creates a tree with circle and triangle leaves."
                    }
                }
            }
        },
        "magnetSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "magnet",
                    "author": "",
                    "readme": {
                        "en": "This example deforms the grid by using the metaball's force.\n\nAdding more or less weight to the metaball changes the deformation amount."
                    }
                }
            }
        },
        "materialSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "material",
                    "author": "",
                    "readme": {
                        "en": "The Material SOP allows you to assign textures to geometry at the SOP level. This is useful if you need to texture a specific part of a more complex piece of geometry, as it takes precedence over the Material soecified in the Geometry component parameter."
                    }
                }
            }
        },
        "mergeSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "merge",
                    "author": "",
                    "readme": {
                        "en": "This example merges three diferent SOPs."
                    }
                }
            }
        },
        "metaballSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "metaball",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates the Metaball SOPs property of changing their shape to adapt and fuse with surrounding metaballs."
                    }
                }
            }
        },
        "noiseSOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "points",
                    "author": "",
                    "readme": {
                        "en": "This example applies a Sparse noise to the point positions."
                    }
                },
                "1": {
                    "title": "normals",
                    "author": "",
                    "readme": {
                        "en": "This example applies a Hermite noise to the sphere's normals."
                    }
                },
                "2": {
                    "title": "diffuse color",
                    "author": "",
                    "readme": {
                        "en": "This example applies Sparse noise to the sphere's diffuse color."
                    }
                },
                "3": {
                    "title": "alpha",
                    "author": "",
                    "readme": {
                        "en": "This example applies a Sparse noise to the point alpha."
                    }
                },
                "4": {
                    "title": "texture",
                    "author": "",
                    "readme": {
                        "en": "Here we've actually applied the noise to the point texture UV coordinates."
                    }
                },
                "5": {
                    "title": "noise",
                    "author": "",
                    "readme": {
                        "en": "This example combines applying noise to the diffuse color and the point positions."
                    }
                }
            }
        },
        "objectmergeSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "merge",
                    "author": "",
                    "readme": {
                        "en": "You can use an Object Merge SOP to merge geometry."
                    }
                },
                "1": {
                    "title": "component transforms",
                    "author": "",
                    "readme": {
                        "en": "The interesting aspect of the Object Merge SOP is that it takes the transform parameters of the referenced SOPs Geometry Component into account.\n\nSee the above and below example that yield the same results. In the above example, all the transforms are done at the SOP level, while in the below example, all the transforming is done at the Component level."
                    }
                }
            }
        },
        "particleSOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "modify source",
                    "author": "",
                    "readme": {
                        "en": "These two examples show the two different modes\nof the Particle SOP.\n\nThe first is to use the input geometry for emitting \nthe particles.\n\nThe second is to modify the input geometry using the\nparticles."
                    }
                },
                "1": {
                    "title": "collision",
                    "author": "",
                    "readme": {
                        "en": "There are 3 different collision modes for particles. \n\nThe first is to bounce on collision.\n\n The second is to die on collision.\n\nThe third is to stick on collision."
                    }
                },
                "2": {
                    "title": "wind",
                    "author": "",
                    "readme": {
                        "en": "This example adds some wind to the X axis. "
                    }
                },
                "3": {
                    "title": "turbulence",
                    "author": "",
                    "readme": {
                        "en": "This example adds turbulence to the wind, giving it more natural and random movement."
                    }
                },
                "4": {
                    "title": "wind collision",
                    "author": "",
                    "readme": {
                        "en": "This example combines wind values and stick on contact collisions to give a very simple snow-like effect."
                    }
                },
                "5": {
                    "title": "force",
                    "author": "",
                    "readme": {
                        "en": "These examples show you how to use a Metaball SOP and a Force SOP to create forces more complex than Wind."
                    }
                },
                "6": {
                    "title": "point sprites",
                    "author": "",
                    "readme": {
                        "en": "This is an example of how to use a Particle system to instance  point sprites."
                    }
                },
                "7": {
                    "title": "particles on the GPU",
                    "author": "",
                    "readme": {
                        "en": "Look at the Palette component particlesGpu. Particles on the GPU run much faster."
                    }
                }
            }
        },
        "pointSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "point",
                    "author": "",
                    "readme": {
                        "en": "In this example we've taken the points of the sphere and performed simple operations on their tx and ty parameters."
                    }
                }
            }
        },
        "primitiveSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "deformation",
                    "author": "",
                    "readme": {
                        "en": "In this example the Primitive SOP is used to transform each individual primitive of the input geometry.\n\nWe've specifically rotated each primitive 40 degrees on the Z axis.\n\nClick the 'Do Transformation' on and off to see a before and after."
                    }
                },
                "1": {
                    "title": "close curved",
                    "author": "",
                    "readme": {
                        "en": "Here we've closed the open circle using a curved surface. "
                    }
                },
                "2": {
                    "title": "close straight",
                    "author": "",
                    "readme": {
                        "en": "Here we've closed the circle using a straight line. "
                    }
                }
            }
        },
        "railsSOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "rails",
                    "author": "",
                    "readme": {
                        "en": "The example uses two Line SOPs as  the rails and creates a bigger copy of rectangle as the rails move further apart."
                    }
                },
                "1": {
                    "title": "rails1",
                    "author": "",
                    "readme": {
                        "en": "This is another basic example of  using the Rails SOP.\n\nIt is similar to the above example except that the  rails are parallel."
                    }
                },
                "2": {
                    "title": "points",
                    "author": "",
                    "readme": {
                        "en": "This example shows the more points there are along the rails the more copies of the  input geometry are made."
                    }
                },
                "3": {
                    "title": "points1",
                    "author": "",
                    "readme": {
                        "en": "This example uses curved rails. Notice how the offset of the rails creates copies of the input geometry on an angle, as it creates the copy between point 0 of both rails."
                    }
                }
            }
        },
        "raySOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "ray",
                    "author": "",
                    "readme": {
                        "en": "In this example we've used the Ray SOP to project the flat text onto the surface of the sphere. "
                    }
                }
            }
        },
        "rectangleSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "plane",
                    "author": "",
                    "readme": {
                        "en": "You can select which plane you'd like your rectangle to occupy.\n\nEach one of these 3 examples uses different plane settings."
                    }
                },
                "1": {
                    "title": "fill camera",
                    "author": "",
                    "readme": {
                        "en": "Try looking around in the Viewer of 'cam1' and the rectangle will always fill the camera's view."
                    }
                }
            }
        },
        "refineSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "refine",
                    "author": "",
                    "readme": {
                        "en": "Here we've increased the amount of points between the First U and Second U parameters. "
                    }
                }
            }
        },
        "resampleSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "resample",
                    "author": "",
                    "readme": {
                        "en": "This example resamples the input geometry with a maximum length segment of 0.1, creating more evenly spaced points along the geometry."
                    }
                },
                "1": {
                    "title": "segments",
                    "author": "",
                    "readme": {
                        "en": "This examples uses the Along Arc measure to resample the input geometry.\n\nBy animating the Segments parameter, we can see the arc change as the segments increase."
                    }
                }
            }
        },
        "revolveSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "revolve",
                    "author": "",
                    "readme": {
                        "en": "This example uses the Revolve SOP to create a surface via the revolution of the input geometry. "
                    }
                }
            }
        },
        "scriptSOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "copy and add",
                    "author": "",
                    "readme": {
                        "en": "In this example, we use the Script SOP to copy the contents of transform1, as well as creating a 5-vertex closed polygon.\n\nSee docs.derivative.ca/Geometry_Detail."
                    }
                },
                "1": {
                    "title": "modify and add",
                    "author": "",
                    "readme": {
                        "en": "This example uses the Script SOP to run a simple operation on every point in the sphere.\n\nIt also creates a 3-sided polygon.  \n\nThe expressions that control the animation\nof the geometry are added to custom parameters."
                    }
                },
                "2": {
                    "title": "triangle custom attributes",
                    "author": "",
                    "readme": {
                        "en": "This creates a triangle and then adds some attributes, both built-in custom attrbutes and user-defined custom attributes.\n\nNote you can creatre attributes on points, or attributes on teh verties of a primitive (like a triangle).\n\nIt shows how to add the uvw texture coordinates as a point attribute using pointAttribs.create('uv'), and then set uv values for the points. \n\n(Note you can set uvw on polygon vertices too, independent of the points list. See the Texture SOP.)\n\nright-click on the viewer and select Display Options to get the uv coordinatas to display.\n\nThe SOP to DAT shows the point attributes in a table."
                    }
                },
                "3": {
                    "title": "scatter",
                    "author": "",
                    "readme": {
                        "en": "This creates a scattering of points along a surface."
                    }
                },
                "4": {
                    "title": "custom parameters",
                    "author": "",
                    "readme": {
                        "en": "This example uses Custom Parameters to create a polygon with 3-6 points.\n\nThe custom integer slider is defined in the setupParameters callback, and is read from the cook callback."
                    }
                },
                "5": {
                    "title": "scatter pulse",
                    "author": "",
                    "readme": {
                        "en": "This creates a scattering of points along a surface, similar to the previous example, but instead adds a Custom Parameter Pulse button to create a new seed value for the random points. This seed is stored in the callback script's Python storage, and can be seen using the Examine DAT."
                    }
                },
                "6": {
                    "title": "bezier curve",
                    "author": "",
                    "readme": {
                        "en": "In this example, we use the Script SOP to copy the contents of transform1, as well as creating a 5-vertex closed polygon.\n\n"
                    }
                },
                "7": {
                    "title": "five surfaces",
                    "author": "Guido Schmidt",
                    "readme": {
                        "en": "The Script SOP creates 5 topologies of surfaces.\n\nUse the \"switch1\" operator to switch between the python scripts on the left. Each python script shows how to program different geometry using a Script SOP.\n\n--------\ntutorial: https://guidoschmidt.cc/j/2020/td-generative-meshes\nauthor: Guido Schmidt <mail@guidoschmidt.cc>"
                    }
                }
            }
        },
        "sequenceblendSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "sequence blend",
                    "author": "",
                    "readme": {
                        "en": "The Sequence Blend SOP allows us to blend between different inputs.\n\nUse the slider to blend between these three different shaped boxes."
                    }
                },
                "1": {
                    "title": "animate",
                    "author": "",
                    "readme": {
                        "en": "This example animates a blend across four different boxes."
                    }
                }
            }
        },
        "skinSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "skin",
                    "author": "",
                    "readme": {
                        "en": "This example creates a skin between the two merged grids."
                    }
                },
                "1": {
                    "title": "skin1",
                    "author": "",
                    "readme": {
                        "en": "This example creates a surface between the two curves."
                    }
                },
                "2": {
                    "title": "output",
                    "author": "",
                    "readme": {
                        "en": "This example creates a very interesting pattern by skinning across the columns and outputting polygons."
                    }
                }
            }
        },
        "sortSOP": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "sort points",
                    "author": "",
                    "readme": {
                        "en": "The simplest function of the Sort SOP is to sort and change the order of the points of the incoming geometry."
                    }
                },
                "1": {
                    "title": "random",
                    "author": "",
                    "readme": {
                        "en": "You can sort the points in a random order.\n\nThis example animates the Random seed, allowing you  to see the point numbers change."
                    }
                },
                "2": {
                    "title": "primitives1",
                    "author": "",
                    "readme": {
                        "en": "Sort SOP allows you to sort the numbers of primitives.\n\nThis example puts them in a random order."
                    }
                },
                "3": {
                    "title": "primitives2",
                    "author": "",
                    "readme": {
                        "en": "This example sorts the  primitives in reverse order."
                    }
                },
                "4": {
                    "title": "primitives3",
                    "author": "",
                    "readme": {
                        "en": "This example deletes primitives within a certain range.\n\nBecause the Sort SOP's random seed is animated, the primitives that fall within that range are changing, thus creating the animated pattern."
                    }
                },
                "5": {
                    "title": "transparency",
                    "author": "",
                    "readme": {
                        "en": "When doing transparency two main things need to be done: Turn on Blending in the Common page of the MAT, and ensure your primitive are sorted farthest to nearest. Notice how the random sorted geometry looks wrong, even though it's the same geometry as the one that's properly sorted.\n\nIf you have the horsepower, another way do to transparency is to use Order Independent Transparency on the Advanced page of the Render TOP. Adjust the Transparency Passes parameter to see the randomly sorted geometry become more/less correctly. Depending on the scene only a few passes may be needed to create an  acceptable look."
                    }
                },
                "6": {
                    "title": "particles",
                    "author": "",
                    "readme": {
                        "en": "The particle system on the left is not properly sorted farthest to closest, while the one on the right is. Notice the blending artifacts only appear if they particles are not proplery sorted.\n\nOrder Independent Transparency can also be used to help fix particle system blending artifacts, however many passes are needed.\n"
                    }
                }
            }
        },
        "sphereSOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "sphere",
                    "author": "",
                    "readme": {
                        "en": "This Sphere SOP creates a sphere \"primitive spheret type\". which is not a set of polygons, but defined by a center point and radius.\n\nMiddle-click on the node (Alt-rightclick without a proper 3-button mouse) to see that it is a spehere primitive and no polygons or meshes.\n\nIn wireframe (press Viewer Active and then 'w') it is represented as three circles.\n\nTo change it to polygons or a mesh, change the Primitive Type menu and check the info (again, middle mouse click or, click the \"i\" on the parameter dialog)."
                    }
                },
                "1": {
                    "title": "frequency",
                    "author": "",
                    "readme": {
                        "en": "This example lowers the frequency of the polygon count of the Sphere, making it more jagged."
                    }
                },
                "2": {
                    "title": "mesh",
                    "author": "",
                    "readme": {
                        "en": "You can use meshes to create spheres, as well as NURBS and Bezier curves."
                    }
                },
                "3": {
                    "title": "radius",
                    "author": "",
                    "readme": {
                        "en": "You can control the shape of the sphere by using the Radius parameters."
                    }
                },
                "4": {
                    "title": "input",
                    "author": "",
                    "readme": {
                        "en": "You can use the input of a Sphere SOP to create a sphere around the input geometry."
                    }
                }
            }
        },
        "springSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "spring",
                    "author": "",
                    "readme": {
                        "en": "This example demonstrates the ability of the Spring SOP to deform geometry based on simple physics simulations. "
                    }
                }
            }
        },
        "stitchSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "stitch",
                    "author": "",
                    "readme": {
                        "en": "Here the Stitch SOP is used to stitch  the two sphere fragments together into a smooth surface."
                    }
                }
            }
        },
        "subdivideSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "subdivide",
                    "author": "",
                    "readme": {
                        "en": "This example changes the Box in input 1 to the low polygon count Sphere in input 2."
                    }
                },
                "1": {
                    "title": "sphere",
                    "author": "",
                    "readme": {
                        "en": "You can turn a Cube into a Sphere using the Subdivide SOP with a Depth of 2."
                    }
                }
            }
        },
        "superquadSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "super-quadratic surfaces",
                    "author": "",
                    "readme": {
                        "en": "Super Quadratic math generates shapes within a 1 unit cube.\n\n\nIncluding a rounded box."
                    }
                }
            }
        },
        "sweepSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "sweep",
                    "author": "",
                    "readme": {
                        "en": "This is a simple example of how to use a Sweep SOP.\n\nThis example places a copy of the input G at each point of the backbone."
                    }
                },
                "1": {
                    "title": "skin and close",
                    "author": "",
                    "readme": {
                        "en": "This example is the same as the above, except that the Sweep SOP is set to skin and close the output geometry."
                    }
                },
                "2": {
                    "title": "twist and roll",
                    "author": "",
                    "readme": {
                        "en": "You are able to twist and roll the copies placed on the backbone."
                    }
                }
            }
        },
        "switchSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "switch",
                    "author": "",
                    "readme": {
                        "en": "The Switch SOP in this example switches between the two inputs."
                    }
                }
            }
        },
        "textSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "text",
                    "author": "",
                    "readme": {
                        "en": "The Text SOP is used to create 3D type.\n\nHere we've animated the Bold and Italic parameters to demonstrate basic formatting.\n\nFor more formatting options, see the Font SOP."
                    }
                }
            }
        },
        "textureSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "texture",
                    "author": "",
                    "readme": {
                        "en": "All these examples show the various ways of assigning UV and W cooridnates to input geometry, with the ability to scale and offset the texture in the process."
                    }
                }
            }
        },
        "torusSOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "rows and cols",
                    "author": "",
                    "readme": {
                        "en": "You can use the Rows and Columns parameters to control the polygon count of a Torus SOP."
                    }
                },
                "1": {
                    "title": "types",
                    "author": "",
                    "readme": {
                        "en": "There are different Torus types you can  create, including Polygon, Mesh, NURBS, and Bezier.\n\nThis example is a mesh."
                    }
                },
                "2": {
                    "title": "nurbs",
                    "author": "",
                    "readme": {
                        "en": "This example is NURBS Torus."
                    }
                },
                "3": {
                    "title": "radius",
                    "author": "",
                    "readme": {
                        "en": "You can control the shape of a Torus using the raidus parameters."
                    }
                },
                "4": {
                    "title": "center1",
                    "author": "",
                    "readme": {
                        "en": "You can translate the Torus using the Center parameters."
                    }
                }
            }
        },
        "traceSOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "trace",
                    "author": "",
                    "readme": {
                        "en": "This example traces Smiley.tif and extrudes the traced image."
                    }
                },
                "1": {
                    "title": "trace movie",
                    "author": "",
                    "readme": {
                        "en": "You are able to also trace movies."
                    }
                },
                "2": {
                    "title": "fit to curve",
                    "author": "",
                    "readme": {
                        "en": "Notice how the 2nd example fits the steps to a curve. "
                    }
                }
            }
        },
        "trailSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "trail",
                    "author": "",
                    "readme": {
                        "en": "The Trail SOP creates trails of movement.\n\nHere we've used it to create a trail of the movement of the different primitives of the noise affected box."
                    }
                }
            }
        },
        "transformSOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "transform",
                    "author": "",
                    "readme": {
                        "en": "You should always try to  do most of your transforming at the Component level (on your Geo Component, instead of your SOPs), as it requires far less of your computer's  resources.\n\nThis becomes especially apparent when animating transforms."
                    }
                },
                "1": {
                    "title": "translate",
                    "author": "",
                    "readme": {
                        "en": "These examples translate the box in 3D space."
                    }
                },
                "2": {
                    "title": "scaling",
                    "author": "",
                    "readme": {
                        "en": "Transform SOP can be used to scale as well. "
                    }
                },
                "3": {
                    "title": "rotate",
                    "author": "",
                    "readme": {
                        "en": "This example rotates the text 180 degrees on the Z axis. "
                    }
                },
                "4": {
                    "title": "rotate1",
                    "author": "",
                    "readme": {
                        "en": "This example rotates the torus 100 degrees on the X axis."
                    }
                },
                "5": {
                    "title": "look at",
                    "author": "",
                    "readme": {
                        "en": "Rotate around the Torus in Viewer of 'cam1' and you'll see the Torus will re-orient itself to face the camera."
                    }
                }
            }
        },
        "twistSOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "axis",
                    "author": "",
                    "readme": {
                        "en": "You can change the axis that the Twist SOP is applied to."
                    }
                },
                "1": {
                    "title": "twist",
                    "author": "",
                    "readme": {
                        "en": "The Twist SOP is capable of a couple of different  operations.\n\nOn the right you'll see some examples of them, including bending, shearing, tapering, and squashing."
                    }
                }
            }
        },
        "wireframeSOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "wireframe",
                    "author": "",
                    "readme": {
                        "en": "You can use the Wireframe SOP to create wireframes of the input geometry. \n\nThis example features rounded corners and a thick wire radius."
                    }
                }
            }
        }
    },
    "TOP": {
        "addTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "add images rgb",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Add TOP can take 2 inputs and add their color values together."
                    }
                },
                "1": {
                    "title": "transform and add",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "This example performs basic transform operations on the incoming signals."
                    }
                }
            }
        },
        "analyzeTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "enhance image",
                    "author": "",
                    "readme": {
                        "en": "Analyze TOPs get the darkest pixel and the  brightest pixel of the muddy \"source\" images. This network adjusts levels so the image range is 0 to 1.\n\nNote that Analyze by default creates an image with 1 pixel.\n\nDoesn't quite work right as Mono needs the  lowest of R G and B, but it's useful enough to normalize most images.\n\nIt might be better to work the TOPs in 12 or  16-bits per pixel because precision is lost  at 8 bits per pixel channel.\n\nThis technique requires you to go back to the  CPU to drive the Luma Level. You can switch the TOP to CHOP to Next Frame. Another approach can keep it all on the GPU.\n\n"
                    }
                },
                "1": {
                    "title": "analyze rows columns",
                    "author": "",
                    "readme": {
                        "en": "These Analyze TOPs analyze each row or column and puts the results in a 1-pixel wide strip.\n\nThe Resoltion TOPs are not changing the pixel resolution. They are changing only the image aspect ratio, so the  pixels are stretched."
                    }
                },
                "2": {
                    "title": "analyze range",
                    "author": "",
                    "readme": {
                        "en": "Analyze the maximum and minimum range of a TOP rgba channels.\n\nNote the Analyze TOPs' Analyze Channel parameter are set to RGBA Independent so the max / min are calculated separately for each channel.  The default Analyze Channel is set to Luminance, which finds the brightest pixel and uses the RGBA of that pixel.\n\nThe nodes inside anayzeRange will not cook (consume cpu/gputime) if its viewer is turned off or you are in another network AND its output CHOP is not used."
                    }
                }
            }
        },
        "antialiasTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "anti-alias by edge detect",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Anti Alias TOP is used to smooth out rough edges on diagonal lines.\n\nIt works by performing an edge detection (which can be manipulated by changing the Quality parameter to Custom) then it uses that information to blur the edges."
                    }
                }
            }
        },
        "blobtrackTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "track center of blobs",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Blob Track TOP can be used to calculate positions of blobs in a texture.\n\nOne practical use case would be to calculate touch point positions from an optically captured touch surface.\n\nThe Info DAT is used to extract the values from the Blob Track TOP.\n\nFor more information on the parameters please see the WIKI."
                    }
                },
                "1": {
                    "title": "track warping blobs",
                    "author": "greg",
                    "readme": {
                        "en": "Here you can see the behavior and limit of the blob tracker. \n\nThe Resolution TOP scales to quarter-resolution\n\nThe Monochrome TOP does nothing practical as Blob Trach is converting it to monochrome.\n\nBob Track does best with maximum-contrast images: Bypass the Luma Level to see.\n\nIf you drop Minimum Move Distance down too much, it will think all blobs are new each frame, so the \"id\" channel will rise quickly for what seems like the same blob.\n\nIt's using square areas, so it is not sensitive to odd shapes or optimized for circular shapes.\n\ntriangles are rotated based on blob id."
                    }
                }
            }
        },
        "blurTOP": {
            "num_samples": 9,
            "examples": {
                "0": {
                    "title": "simple blur",
                    "author": "",
                    "readme": {
                        "en": "The simplest blur with the Filter Size parameter."
                    }
                },
                "1": {
                    "title": "preshrink and blur",
                    "author": "",
                    "readme": {
                        "en": "A faster and more extreme blur by shrinking the image and blurring that.\n\nIt internally scales it up again."
                    }
                },
                "2": {
                    "title": "blur fraction of image",
                    "author": "",
                    "readme": {
                        "en": "Assume you don't know what the incoming resolution is, but you know you want to blur 10% of the width of whatever image comes in. \n\nThe Filter Size parameter is expressed in pixels and will be the horizontal resolution * .1.\n\nTry connecting butterfly128 to blurFractiom."
                    }
                },
                "3": {
                    "title": "sample step",
                    "author": "",
                    "readme": {
                        "en": "The sample step controls the direction that the blur is applied."
                    }
                },
                "4": {
                    "title": "rotation",
                    "author": "",
                    "readme": {
                        "en": "In this example the direction of the blur is rotated."
                    }
                },
                "5": {
                    "title": "quality",
                    "author": "",
                    "readme": {
                        "en": "The Pre-Shrink and Filter size control the amount and quality of the blur.  \n\nPre-shrink of 2 or 4 etc will first reduce the image resolution, then the blur is appled to the smaller image, and then it is scaled up. This is less accurate but much faster."
                    }
                },
                "6": {
                    "title": "channel",
                    "author": "",
                    "readme": {
                        "en": "You can control  which channel the blur will affect on the Common page."
                    }
                },
                "7": {
                    "title": "dithering",
                    "author": "",
                    "readme": {
                        "en": "You can use a  Blur TOP  to dither an incoming signal. This is helpful when working with low quality assets where there is color banding. "
                    }
                },
                "8": {
                    "title": "erode",
                    "author": "",
                    "readme": {
                        "en": "Generates a softened alpha channel from the alpha of the original image.\n\nblur1 determines how far to cut into the edge.\n\nNear the edge, blurred alpha is about .5, so lookup eliminates alpha outside the border where alpha < .5.\n\nlookup1 TOP is set to display alpha channel. In the Inside TOP, this alpha/Input 2 is used to determine what parts of the  Input1 image are visible. "
                    }
                }
            }
        },
        "cacheTOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "",
                    "readme": {
                        "en": "The Cache TOP can be used to simply delay images.\n\nHere the Cache Size is set to 11 to hold the current image and the image 10 cooks ago.\n\nThe time-delay is not exact because it caches one image per timeline cook, so if you are running about 22 frames per second, it will be a delay of 10/22 seconds. \n\nThe Output Index is usually 0 or a negative number, like -10, as you think of the output image being from 10 frames ago.\n"
                    }
                },
                "1": {
                    "title": "cache",
                    "author": "",
                    "readme": {
                        "en": "You can pre-fill all the frames of a Movie File In TOP into a Cache TOP and then scrub through them.\n\nThe prefill needs to capture one image of the movie per timeline frame. Here this is done by making the movie play one index per frame, starting at the first frame of then movie (index 0).\n\nYou need to use me.time.frame to control what goes into the cache for a certain index:\n\nThe prefill is done by secretly moving the frame to 1 and stepping forward one frame per cache image. See the Index parameter of the Movie File In TOP.\n\nThe Transform TOP also uses me.time.frame to zoom up from about 20%."
                    }
                },
                "2": {
                    "title": "Pre fill",
                    "author": "",
                    "readme": {
                        "en": "Two Cache Select TOPs selecting from one Cache TOP.\n\nYou can pre-fill all the frames of a Movie File In TOP into a Cache TOP and then scrub through them using two Cache Selext TOPs.\n"
                    }
                },
                "3": {
                    "title": "trails",
                    "author": "",
                    "readme": {
                        "en": "This example uses 2 Cache TOPs to create trails of the original image. By setting the Output Index, you can adjust how close to the current frame the Cache TOPs output is."
                    }
                },
                "4": {
                    "title": "time blur",
                    "author": "",
                    "readme": {
                        "en": "This simply averages the last 4 frames, like a multi-exposure.\n\nTry Composite TOP Operations Maximum.\n\nThis can be made more controllable by adding Level TOPs after each Cache Select TOP and adjust their relative Brightness (like .5, .33, .25, .2), then Add-ing them in comp1. This would make the most recent frame more visible."
                    }
                }
            }
        },
        "cacheselectTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "raganmd",
                    "readme": {
                        "en": "The Cache Select TOP allows you to extract a frame from a Cache TOP. In this case we can use the slider to scrub  back through time and off-set the Cache TOP relative to the total number of frames in the original movie. Pausing the time line and using the slider to scrub backwards through time will help to illustrate how this works.\n\nNote that you can have several Cache TOPs retrieving from one Cache TOP.\n\nMatthew Ragan\n8/13/14"
                    }
                }
            }
        },
        "channelmixTOP": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "mix exclude",
                    "author": "",
                    "readme": {
                        "en": "R = G + B G = R + B B = R + G"
                    }
                },
                "1": {
                    "title": "red",
                    "author": "",
                    "readme": {
                        "en": "This example adds all the incoming RGB channels into the Red channel.\n\nSince the green strip is low-brightness, there is a dark strip in the output."
                    }
                },
                "2": {
                    "title": "no green",
                    "author": "",
                    "readme": {
                        "en": "The adding of the Red and Blue channels into each others channels creates purple. Green is 0."
                    }
                },
                "3": {
                    "title": "subtract",
                    "author": "",
                    "readme": {
                        "en": "In this example we subtract the alpha from Green and Blue channels, leaving only Red.\n\nThe Level TOP can produce similar effects, but cannot mix channels."
                    }
                },
                "4": {
                    "title": "subtract1",
                    "author": "",
                    "readme": {
                        "en": "In this example we subtracted white from the signal, leaving black.\n\nR = R - 1 is always <1, which clamps at black for 8-bit color."
                    }
                },
                "5": {
                    "title": "floating point mix",
                    "author": "",
                    "readme": {
                        "en": "This time the ramp is created as  floating point pixels, as you see on the Common page.\n\nThat means pixels can go below zero, though they will look black when displayed on a monitor, as you see in chanmix_subtract_white1.\n\nBut when you add white back in, you get the original colors back, since they are in the range 0 to 1 again.\n\nIf it's done as 8-bit, then chanmix_subtract_white2 clamps at 0 and adding white gives white.\n\nThe Analyze TOP and TOP to CHOP show the minimum values in a pixel, which are below 0 in the 16-bit floating point image.\n\n "
                    }
                },
                "6": {
                    "title": "constant",
                    "author": "",
                    "readme": {
                        "en": "Here we force alpha to be 1 by adding 1 to the alpha channel."
                    }
                }
            }
        },
        "choptoTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "pixel",
                    "author": "",
                    "readme": {
                        "en": "This example uses the RGBA values from topto1 to  create a pixel. "
                    }
                },
                "1": {
                    "title": "multisample",
                    "author": "",
                    "readme": {
                        "en": "This CHOP to creates a pixel for every sample of noise."
                    }
                }
            }
        },
        "chromakeyTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "separate via HSV",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Chroma Key TOP can be used to extract parts of an image based on Hue, Saturation, and Value.\n\nOne common application is to extract people and objects from a green screen.\n\nThe Soft Low and Soft High parameters can be used to feather the edge.\n\nCheck out the chromaKey component in the Pallete for a well-featured use case."
                    }
                }
            }
        },
        "circleTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "rim and bar",
                    "author": "",
                    "readme": {
                        "en": "Circle as a rim and a bar."
                    }
                },
                "1": {
                    "title": "triangle indicator",
                    "author": "",
                    "readme": {
                        "en": "Circle used as a triangle indicator."
                    }
                }
            }
        },
        "compositeTOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "all blend modes",
                    "author": "",
                    "readme": {
                        "en": "After you look at the examples here, get the example Dialogs -> Tools called blendModes."
                    }
                },
                "1": {
                    "title": "methods",
                    "author": "",
                    "readme": {
                        "en": "There are many different types of compositing algorithms available. Here are a few examples. "
                    }
                },
                "2": {
                    "title": "many inputs",
                    "author": "",
                    "readme": {
                        "en": "The Composite TOP can take many inputs and composite them simultaneously."
                    }
                },
                "3": {
                    "title": "transform",
                    "author": "",
                    "readme": {
                        "en": "This example  performs basic  transform operations on the incoming signals."
                    }
                },
                "4": {
                    "title": "translate step",
                    "author": "",
                    "readme": {
                        "en": "This example uses the Translate Step parameter to animate inputs  3 and 4.  \n\nFirst input is fixed/static, that is it is not translated. Also it means the output resolution is that of the first input. \n\nThe next input steps further than the previous."
                    }
                },
                "5": {
                    "title": "more",
                    "author": "",
                    "readme": {
                        "en": "more examples from early-088"
                    }
                }
            }
        },
        "constantTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "solid colors",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Constant TOP is used to make a single color texture at any resolution.\n\nIt is probably the most basic of TOPs but possibly the most commonly used in its category.\n\nOne application might be to create a \"canvas\" of a desired resolution to place other images on with other compositing TOPs like the Over TOP and Composite TOP."
                    }
                }
            }
        },
        "convolveTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "combine neighbors",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Convolve TOP uses a DAT table containing numeric coefficients. For each pixel, it combines its RGBA values and it's neighboring pixels' RGBA values by multiplying the values by the corresponding coefficients in the table, adding the results together. For example, if the table is 5 rows and 5 columns, the pixel and its 24 neighbors are combined."
                    }
                }
            }
        },
        "cornerpinTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "pinning",
                    "author": "",
                    "readme": {
                        "en": "The Corner Pin TOP allows you to move the corner points of an image in x and y.\n\nNOTE: First there is an Extract page that has similar  parameters, but it cuts the image out before applying the corner pinning on the Pin page. Extract examples below."
                    }
                },
                "1": {
                    "title": "background color",
                    "author": "",
                    "readme": {
                        "en": "You can apply a background color after you have corner pinned an image."
                    }
                },
                "2": {
                    "title": "extract",
                    "author": "",
                    "readme": {
                        "en": "The Extract page allows you to specify a sub-section of the image to use by moving 4 points.\n\nIt is different than cropping in that it keeps the original signal's resolution.\n\nThe last example forces the output resolution to be square."
                    }
                }
            }
        },
        "cropTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "Note",
                    "author": "",
                    "readme": {
                        "en": "The Crop TOP actually crops out the pixels in an image, whereas the Corner Pin TOP's \"Extract\" function keeps your image size intact while isolating a specific part of the image."
                    }
                },
                "1": {
                    "title": "area",
                    "author": "",
                    "readme": {
                        "en": "These two examples show how to crop a region of an image."
                    }
                },
                "2": {
                    "title": "extend",
                    "author": "",
                    "readme": {
                        "en": "The extend conditions are used in the off-chance that pixels are added to an image after a crop operation.\n\nIn these examples, the crop is outside the image 0-1 range."
                    }
                }
            }
        },
        "crossTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "cross",
                    "author": "",
                    "readme": {
                        "en": "The Cross TOP crossfades between its two inputs."
                    }
                },
                "1": {
                    "title": "transform",
                    "author": "",
                    "readme": {
                        "en": "The Transform page of the Cross TOP allows you to do basic transform operations on the inputs, thus saving you from having to use a separate Transform TOP afterwards. \n\nThe Fixed Layer is Input 1 so the transform is only applied to Input 2, and the output resolution is Input 1, the Fixed Layer"
                    }
                }
            }
        },
        "cubemapTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "build cube map",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Cube Map TOP builds a texture map in the Cube Map internal texture format. It accepts a vertical cross image, or 1 input per side of the cube. The Phong MAT can use the cube maps from the Cube Map TOP for reflections.\n\nSee also the Projection TOP and the Render TOP."
                    }
                }
            }
        },
        "depthTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "depth map",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Depth TOP reads an image containing depth information from a scene described in a specified Render TOP. The resulting image is black (0) at pixels where the surface is at the near depth value (Camera's parameter \"Near\"). It is white (1) at pixels where the surface is at the far depth value (parameter \"Far\").\n\nThe Depth TOP is used to do shadow mapping. It can have many other uses also, such as edge detection based on depth.\n\nThe depth range is by definition the near plane -> far plane. Values in the Depth TOP will be 0 at the near plane, and 1 at the far plane. Generally the image in the Depth TOP will be white, unless you have your planes really tight around your object. But just because you can't visually see anything, it doesn't mean the information isn't there.\n\nAnother option is Linear Camera-Space Depth. If the Render TOP's Depth Buffer Format is set to 32-Bit Floating-Point and its Linear Camera-Space Depth parameter is on, then the Depth TOP will output linear camera space depth.\n\nYou can use the Level TOP to re-range the Depth TOP's values. However make sure you set the Pixel Format of the Level TOP to 16 or 32-bit, or you'll lose a lot of information from the Depth TOP's data (The Depth TOP has 24-bit data).\n\nThe Depth TOP creates a 24-bit fixed-point or 32-bit floating-point single channel image. When the Depth TOP is used as an input to another TOP, its data will be treated like an RGBA value of (D, D, D, 1). The same is true when sampling a depth texture in a GLSL shader."
                    }
                }
            }
        },
        "differenceTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "difference",
                    "author": "raganmd",
                    "readme": {
                        "en": "The Difference TOP computes the difference between two inputs. In this case we're looking at the difference between a Movie File In TOP and a Cache TOP that is set one frame behind the Movie File In. This allows us to track the change from one frame to another. This can be useful very when analyzing motion. If you have a camera available, you can use the button provided to look at the difference in frame to frame coming from your camera.\n\nMatthew Ragan\n8/13/14\n\nOften it's better to \"cache back\" 2 frames to get a good solid difference. (gh)\n\n\n"
                    }
                }
            }
        },
        "displaceTOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "",
                    "readme": {
                        "en": "For every output pixel, it fetches from nearby the corresponding input pixel. Changing the Displace TOPs Displace Weight allows you to control how heavily the input is displaced in each direction.\n\nNote that some of the noise values go outside the 0-1 range that the colors are clamped to at 8-bits fixed point. But because CHOP to TOP is 32-bit float, the values are not clamped."
                    }
                },
                "1": {
                    "title": "weights",
                    "author": "",
                    "readme": {
                        "en": "For every output pixel, it fetches from nearby the corresponding input pixel. Changing the Displace TOPs Displace Weight allows you to control how heavily the input is displaced in each direction."
                    }
                },
                "2": {
                    "title": "displace by noise",
                    "author": "",
                    "readme": {
                        "en": "The pixels of smiley.tif are being displaced on the X axis by blue channel of the 2nd input noise."
                    }
                },
                "3": {
                    "title": "sizzle",
                    "author": "",
                    "readme": {
                        "en": "This example gets its pixels from random shifts in location in the input image.\n\nRed channels of the second input (the \"Displace Input\") determine the shift horizontally and blue channels determine the shift vertically.\n\nFor each a pixel of the Displace Image, if its red is less than .5, it get a pixel from the left of the corresponding Source Image pixel. \n\nIf its blue is more than .5, it get a pixel from above the corresponding Source Image pixel.\n\nWhy .5? Because the Source Midpoint is set to .5 .5.\n\nAlso, noise_displacer gets its resolution from moviein_displace."
                    }
                },
                "4": {
                    "title": "sizzle 2",
                    "author": "",
                    "readme": {
                        "en": "This example does the same thing as above but the slider adjusts the contrast of the Displace image to grey, versus the above example where the slider adjusts the Displace Weight parameter."
                    }
                }
            }
        },
        "edgeTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "basic edge",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Edge TOP finds edges in an image and highlights them. For each pixel, it looks at the values at neighboring pixels, and where differences are greater than a threshold, the output's value is higher."
                    }
                },
                "1": {
                    "title": "edge facemelt",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "If you fancy yourself a mad lad, try putting an Edge Detect TOP in a feedback loop.\n\n#facemelt"
                    }
                }
            }
        },
        "embossTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "raised edges",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The Emboss TOP creates the effect that an image is embossed in a thin sheet of metal. Edges in the image will appear raised."
                    }
                }
            }
        },
        "feedbackTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "time-blur",
                    "author": "",
                    "readme": {
                        "en": "A simple feedback setup that gives fake motion blur by using a fraction (x) of the current image (transform1) plus 1-x of the prior frame's image. \n\nWith the Cross TOP, this has limited blending control."
                    }
                },
                "1": {
                    "title": "feedback blends",
                    "author": "",
                    "readme": {
                        "en": "This takes the current image combined with a fraction (reduce_opacity) of the prior image.\n\nYou can try different Composite blend modes to control the mixing, and try both rectangle1 and fit1 into rotate:\n\n  Screen - tame, versatile, doesn't burn out\n  Add - more dynamic\n  Maximum - punchy\n  Over - will always show source but needs alpha\n  Difference - psychotic\n\nIf you change Source's resolution, change res on constant1 and press Reset on feedback1. Or connect your source into feedback1 and press Reset tomake it your starting image\n\n"
                    }
                },
                "2": {
                    "title": "feedback fx",
                    "author": "",
                    "readme": {
                        "en": "Feedback with more effects. alter nodes: \n\nopacity: Opacity - fade out trail\nlumalevel1: boost Gamma or Brightness\nreduceHighRed - isolate colors\nhavadjust1 - Hue Offset, boost Saturation\ntransform1 - Scale, Translate - expand\ndisplace1 - un-bypass, Displace Weight\nnoise1 \nblur1 - Filter Size to soften\nedge1 - unbypass, Strength, Edge Color\n\ncomp1 - different blend modes\nlevel2 - fill with black (Low A)\n\nChange feedback1 Pixel Format to 16 bit fixed (and press Reset) for better color quantization, or to 32-bit float for better over-driving.\n\n\n"
                    }
                }
            }
        },
        "fitTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "horiz",
                    "author": "",
                    "readme": {
                        "en": "The Fit TOP changes the resolution and aspect ratio of an image, but does not distort the image.\n\nIn the first example, the new image in fit1 shows the entire horizontal span of the input image.\n\nIn fit2, it shows the entire vertical span but the sides are cut off."
                    }
                },
                "1": {
                    "title": "inside outside",
                    "author": "",
                    "readme": {
                        "en": "To insure the entire image is visible, no matter what the  input and output resolutions are, use Fit Inside.\n\nSecondy, to insure the output image uses as much of of the input image as possible, without distorting and without any blank areas, use Fit Outside.\n\nThis example also scales an extra 1%. "
                    }
                },
                "2": {
                    "title": "1x1 to 16x9",
                    "author": "",
                    "readme": {
                        "en": "A square image is made to fit 16x9."
                    }
                }
            }
        },
        "flipTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "flipping",
                    "author": "",
                    "readme": {
                        "en": "The Flip TOP provides an easy way to flip an image in X (horizontally) or y (vertically)."
                    }
                },
                "1": {
                    "title": "flop",
                    "author": "",
                    "readme": {
                        "en": "A useful feature of the Flip TOP is being able to \"flop\" an image. X becomes Y and Y becomes X.\n\nThis differs from using a Transform TOPs rotation, which rotates the texture contained in the image or movie, but not the canvas.\n\nFlop changes the resolution. "
                    }
                }
            }
        },
        "flowTOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "fire",
                    "author": "jarrett",
                    "readme": {
                        "en": "In this example ramp1 is used to indicate where the emission of fuel comes from.  The ramp position is randomized with noise.  This animated ramp is used as the Shape OP in the flow emitter. This means emission will happen where it is white and less emmision where it is black.\n\nReduce Mem Usage if it gets too slow."
                    }
                },
                "1": {
                    "title": "steam",
                    "author": "jarrett",
                    "readme": {
                        "en": "Use the cross1 TOP to cross fade in an RGB spectrum to see how color is mapped to the temperature of the flow.\n\nMem Usage parameter is reduced from .1 to .07 to run a bit faster.  "
                    }
                },
                "2": {
                    "title": "smokestack",
                    "author": "jarrett",
                    "readme": {
                        "en": " Reduce Speed par to ge more billowy effect."
                    }
                },
                "3": {
                    "title": "gas",
                    "author": "jarrett",
                    "readme": {
                        "en": "Is this example linear velocity is animated to push the fuel source left and right."
                    }
                },
                "4": {
                    "title": "joker flame thrower",
                    "author": "jarrett",
                    "readme": {
                        "en": "Is this example a more intense use of linear velocity is used to create a flame thrower effect."
                    }
                }
            }
        },
        "functionTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "basic math functions",
                    "author": "",
                    "readme": {
                        "en": "ramp1 is set on Common page to output 32-bit floating point numbers as Pixel Format for the RGBA channels\n\nnull4 is same as ramp1 with its viewer set to Normalized Split, where the red (R), green (G) and blue 9B) channels are identical 0-1 ramps.\n\n\nmath1 takes the ramp's 0-1 range and makes it 0 to 1000.\n\nThen the Function TOP computes:\n\nsqrt(0) to sqrt(1000) in the red channel.\ncos(0) to cos(1000) is in green.\n0**2 to 1000**2 goes into blue.\n\nThe bananna is warped in the red and green channels, which is interpreted in a point cloud as X and Y."
                    }
                }
            }
        },
        "glslTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "custom shaders",
                    "author": "matthewwachter",
                    "readme": {
                        "en": "The GLSL TOP renders a GLSL shader into a TOP image. Use the Info DAT to check for compile errors in your shaders.\n\nRefer to the Write a GLSL TOP article for more info on using this TOP.\n\nhttp://www.derivative.ca/wiki099/index.php?title=Write_a_GLSL_TOP"
                    }
                }
            }
        },
        "hsvtorgbTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "make a spectrum",
                    "author": "",
                    "readme": {
                        "en": "Put hue in the first channel, saturation in the second channel, value in the third channel, and use HSV to RGB to interpret those three channels as HSV and convert the image to RGB.\n\nIn this case, hue is a ramp from 0 to 1. In TouchDesigner, a hue of value 0 is red, .33 is green, .66 is blue and 1 is red again.\n "
                    }
                }
            }
        },
        "insideTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "insert image where alpha > 0",
                    "author": "nettoyeur",
                    "readme": {
                        "en": "The Inside TOP places Input1 \"inside\" Input2. The alpha of Input2 is used to determine what parts of the Input1 image are visible. \n\nIdzard Kwadijk\nkwadijk@idzard.com\n "
                    }
                }
            }
        },
        "levelTOP": {
            "num_samples": 8,
            "examples": {
                "0": {
                    "title": "black bright gamma",
                    "author": "",
                    "readme": {
                        "en": "Black level, brightness and gamma adjustment.\n\nThis operates on each red, gree, blue separately.\n\nRefer to the Luma Level TOP too, which will treat the 3 channels together as luminance adjustments, which gives better results sometimes as it maintains hue and saturation."
                    }
                },
                "1": {
                    "title": "invert",
                    "author": "",
                    "readme": {
                        "en": "This Level TOP inverts the colors of the incoming image."
                    }
                },
                "2": {
                    "title": "opacity",
                    "author": "",
                    "readme": {
                        "en": "You can control an image's opacity with the Level TOP."
                    }
                },
                "3": {
                    "title": "color knockout",
                    "author": "",
                    "readme": {
                        "en": "Level TOP can adjust the upper-lower range of each RG and B. This is a different set of controls vs HSV Adjust TOP."
                    }
                },
                "4": {
                    "title": "ranges",
                    "author": "",
                    "readme": {
                        "en": "The Level TOP can modify the incoming and outgoing High and Low values of each pixel.\n\nSee the Math TOP to handle data outside the 0-1 range more generally."
                    }
                },
                "5": {
                    "title": "colors",
                    "author": "",
                    "readme": {
                        "en": "The Level TOP can also perform color correction operations by controlling the Low and High values of the Red, Green, Blue, and Alpha channels independantly."
                    }
                },
                "6": {
                    "title": "step",
                    "author": "",
                    "readme": {
                        "en": "This shows the application of stepping to a smooth ramp."
                    }
                },
                "7": {
                    "title": "post adjust",
                    "author": "",
                    "readme": {
                        "en": "Sometimes you want to adjust gamma first and then the brightness. Use the Post page for this.\n\nYou can also clamp the colors to remain in a certain range."
                    }
                }
            }
        },
        "limitTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "clamp and quantize",
                    "author": "",
                    "readme": {
                        "en": "limit1 sets a minimum of .25 and a maximum of .7 on all channels.\n\nThat includes the alpha channel, which may not be desired. limit2 affects only the red and green channel, using the Channel Mask on the Common page.\n\nlimit3 clamps like limit1, but then Normalizes the result to 0 to 1, and affects RGB only.\n\ntopto1 to 5 have their graphs fixed to the 0 to 1 range: Make their View Active, right-click on the graph, select Vertical Range, 0 1.\n\nramp2 is not linear between black and white: Its interpolation is set to Ease In Ease Out (an S-curve).\n\nThis helps show the difference between limit4 which Quantizes by value, and limit5 which quantizes by position (equal steps in the horizontal axis)."
                    }
                },
                "1": {
                    "title": "color squeezing",
                    "author": "",
                    "readme": {
                        "en": "See RGB to HSV TOP example 2.\n\nSee also the Limit CHOP."
                    }
                }
            }
        },
        "lookupTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "with chop",
                    "author": "",
                    "readme": {
                        "en": "Compose 4 CHOP channels and apply the first CHOP channel to the red TOP channel, and so on.\n\nUnbypass Quantize for a variation."
                    }
                }
            }
        },
        "lumablurTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "filter types",
                    "author": "",
                    "readme": {
                        "en": "These examples show the difference between using a white filter or black filter. See Black Filter Width and White Filter Width parameters.\n\nThey also have different blur Types applied."
                    }
                },
                "1": {
                    "title": "luma",
                    "author": "",
                    "readme": {
                        "en": "This example uses the black and white Count.mov to blur the grid."
                    }
                }
            }
        },
        "lumalevelTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "contrast",
                    "author": "",
                    "readme": {
                        "en": "The Luma Level TOP is useful in situations where you don't want colors getting blown out by a Level TOPs contrast parameters."
                    }
                },
                "1": {
                    "title": "quantized steps",
                    "author": "",
                    "readme": {
                        "en": "You can apply luminance stepping using a Luma Level TOP."
                    }
                }
            }
        },
        "mathTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "un-pre-multiply",
                    "author": "",
                    "readme": {
                        "en": "The Math TOP can help turn images that  have their RGB pre-multiplied by alpha into an image that does not have the RGB pre-multiplied by alpha. \n\nEssentially it divides the RGB by alpha, but it needs to take care of the case where RGB and alpha are very small as divide and round-off errors will give imprecise results.\n\nLevel helps strip out pixels that have alpha < .04."
                    }
                },
                "1": {
                    "title": "re-range",
                    "author": "",
                    "readme": {
                        "en": "Show high pixel value ranges being brought into \"visible range\" (0-1). \n\nNoise in set to be in range 5 to 6. Math brings 5 to 6 down to 0 to 1 for red and blue, and .3 to .7 for green.  Alpha remains un-affected.\n\nmath1 has its Viewer Smoothness set to Nearest Pixel so you can better see the individual pixels.\n\nnull1's viewer is set to Normalized Split so ou can see the ranges there."
                    }
                },
                "2": {
                    "title": "range channels separately",
                    "author": "",
                    "readme": {
                        "en": "Show high pixel value ranges being brought into \"visible range\" (0-1).\n\nmath1 sets the From Ramge max to be whatever is is in the jellybean image, and sets the To range to 0 to 1. \n\nNote the analyze_independent's Analyze Channel parameter is set to RGBA Independent so the max / min are calculated separately for each channel.  (The default Analyze Channel is set to Luminance, which finds the brightest pixel and uses the RGBA of that pixel.)\n\nMore easily, the Limit TOP can normalize the colors to 0-1 in R G B and A."
                    }
                }
            }
        },
        "matteTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "matte",
                    "author": "",
                    "readme": {
                        "en": "This image in input1 is revealed by the luminance of the image in the 3rd input."
                    }
                },
                "1": {
                    "title": "matte2",
                    "author": "",
                    "readme": {
                        "en": "In this case, the Alpha of Ramp1/3rd input controls the opacity of input 2. By default it uses the luminance of input 3."
                    }
                }
            }
        },
        "moviefileinTOP": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "loop stop cue",
                    "author": "",
                    "readme": {
                        "en": "This movie's trim value will keep it looping forever. Its Extend Right parameter is set to Cycle.\n\nExtend Right refers to what the TOP will do once it reaches the end of end movie.\n\nThe second movie's trim value will hold the last frame.\n\nIts Extend Right parameter is set to Hold.\n\nThe Cue button will force the movie to jump to image 20."
                    }
                },
                "1": {
                    "title": "index",
                    "author": "",
                    "readme": {
                        "en": "Use the slider to scrub through the movie by index"
                    }
                },
                "2": {
                    "title": "play",
                    "author": "",
                    "readme": {
                        "en": "Use this button to play the movie. The button state has been exported to the Play parameter. "
                    }
                },
                "3": {
                    "title": "timeline",
                    "author": "",
                    "readme": {
                        "en": "This movie's playback is locked to the main TouchDesigner Timeline. \n\nIts Play Mode Parameter is set to Locked to Timeline.\n\nScrub the timeline below to scrub the movie.\n\nUsing the timeline to play movies is uncommon on TouchDesigner these days. Usually Index and Sequential modes are used."
                    }
                },
                "4": {
                    "title": "reload",
                    "author": "",
                    "readme": {
                        "en": "Use this button to reload the movie in case it has changed on the filesystem.\n\nYou can use the Folder DAT to do it automatically."
                    }
                },
                "5": {
                    "title": "image",
                    "author": "",
                    "readme": {
                        "en": "Movie File In TOPs also support loading still images and image file sequences.\n\nFor image sequences you give it the folder and it will alphanumerically-order the files in that folder.\n\nOr alternately you control it via the filename, which may load slower because the expression cannot be predicted or interpolated.\n\n\nSearch \"File Formats\" on wiki. \n\nSeer also Point File In TOP to read point clouds."
                    }
                },
                "6": {
                    "title": "moviePlayer COMP",
                    "author": "",
                    "readme": {
                        "en": "Try the moviePlayer COMP in the palette for a more full-functioned player and read its wiki page."
                    }
                }
            }
        },
        "moviefileoutTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "recording movie with audio",
                    "author": "",
                    "readme": {
                        "en": "This is a typical Movie Out setup with audio recording synced to an audio track.\n\nThe Record Movie button turns Record on and off, as well as triggers a counter to give each new recording a unique name.\n\nThe Pause button pauses the movie recording while it is on.\n\nAudio is being referenced from audiofilein1.\n\nThe movie is created in your project folder where your .toe is located.\n\nPress Reset pulse on the incrementFilename Count CHOP to reset the sequence number to 1."
                    }
                },
                "1": {
                    "title": "sequence of stills",
                    "author": "",
                    "readme": {
                        "en": "This creates a sequence of files, one file per frame.\n\nThe Record Movie button turns Record on and off, as well as triggers a counter to give each new recording sequence a unique name.\n\nIn the File parameter, me.fileSuffix uses artifishull intelligence to build the end of the file path, something like  .2.14,jpg\n\n\nThe movie is created on the Desktop using the hard-to-find python: app.desktopFolder.  See the App class for more secrets. \ndocs.derivative.ca/App_Class"
                    }
                },
                "2": {
                    "title": "one image file per click",
                    "author": "",
                    "readme": {
                        "en": "The Movie Out TOP can also output still images in a similar manner as video  files."
                    }
                }
            }
        },
        "multiplyTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "multiply",
                    "author": "",
                    "readme": {
                        "en": "The multiply TOP performs a multiply operation:\n\ninput1.rgba * input2.rgba\n\nIn multiply1 it is set to use to output the resolution of the first input. By default it outputs the resolution of the second input, like other 2-input combiners. "
                    }
                }
            }
        },
        "noiseTOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "seed",
                    "author": "",
                    "readme": {
                        "en": "The Noise TOP's Seed parameter is an easy way to create animated noise. The two images are multiplied together in the Composite TOP.\n\nThe Noise TOP is scaled to fit the jellybeans, so you would have to set the resolution of the Noise TOP too to make it not stretched.\n\nThe second example shows you can feed an image to the Noise TOP, and via the Output page, combine the noise and incoming image in different ways.\n\nThe Noise TOP takes the resolution of the incoming TOP."
                    }
                },
                "1": {
                    "title": "algorithms",
                    "author": "",
                    "readme": {
                        "en": "You can get very different types of noise, from Random to Perlin, by changing the  Type parameter. "
                    }
                },
                "2": {
                    "title": "fast random",
                    "author": "",
                    "readme": {
                        "en": "Shifts a random pattern around to give an apparent randomness every frame. Not perfect but may be good enough for many purposes. Much faster than generating perfectly random pixels every frame.\n\nSecond example randomly rotates also, making it more scrambled though some adjacent pixels may have similar values."
                    }
                },
                "3": {
                    "title": "input xyz point positions",
                    "author": "",
                    "readme": {
                        "en": "The Noise TOP takes its input, interprets each pixel RGB value as an XYZ point, and for each point, outputs a pixel whose RGB values are the values of the noise space at that point in space.\n\nIn the first example, chopto1 outputs 32-bit floating point pixels which can represent numbers outside the usual 0-1 color range of 8-bit fixed point pixels.\n\nThe Noise TOP has been changed to a 32-bit float format so that it can output noise values that are outside the 0-1 range.\n\nIn the first example, the Noise TOP's RGB values are used to color the points, but they can be used for anything.\n\nIn the second example, the Ramp and Constant TOPs are set to 32-bit and combined and fed into the Noise TOP. The sliders offset the XYZ positions used to sample the noise space."
                    }
                },
                "4": {
                    "title": "palette noise",
                    "author": "",
                    "readme": {
                        "en": "Try the \"noise\" component in the palette for more choices of noise types."
                    }
                }
            }
        },
        "normalmapTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "fake bump",
                    "author": "raganmd",
                    "readme": {
                        "en": "Matthew Ragan  8/11/14\n\nWe can use the Normal Map TOP to help enhace the appearance of dimension in our textures by \"faking\" some of the lightingof bumps in a texture.\n\nHere we create a normal map from our input image, and then use this along with the original image in our  Phong MAT.\n\nAn additional Level TOP has been used in this example to further draw attention to the effect of the Normal Map.\n\nUse the button to toggle the Normal Map on and off in the Phong Material to better understand the effect of this TOP.\n\nfrom Wikipedia\n\nIn 3D computer graphics, normal mapping, or \"Dot3 bump mapping\", is a technique used for faking the lighting of bumps and dents \u2013 an implementation of bump mapping. It is used to add details \nwithout using more polygons. A common use of this technique is to greatly enhance the appearance and details of a low polygon model by generating a normal map from a high polygon model or height map.\n\nhttp://en.wikipedia.org/wiki/Normal_mapping"
                    }
                }
            }
        },
        "opencolorioTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "jarrett",
                    "readme": {
                        "en": "You can use the CDL transform \nand Output page to colorgrade\nany image."
                    }
                },
                "1": {
                    "title": "sRGB conversion",
                    "author": "malcolm",
                    "readme": {
                        "en": "openColorIO can be used for numerous color correction operations for various output display devices. In this case the OpenColorIO TOP node (sRGBRamp) is used to simulate the conversion of a linear ramp into a gamma lookup image (brightened iamge to use the 256 steps of an 8-bit image bettter), as it would be stored in a JPEG file.  See the wiki page 'sRGB' for more information. https://docs.derivative.ca/SRGB"
                    }
                },
                "2": {
                    "title": "color profiles",
                    "author": "jarrett",
                    "readme": {
                        "en": "OpenColorIO is a toolkit for working with different color spaces and gamma settings for image files. Different cameras and display devices have different methods to store and display color. OpenColorIO supports the loading of different lookup tables (LUTs) that can transform how the color data is stored and viewed.\n\nThe TouchDesigner colorspace is linear. By using OpenColorIO an image that is stored in one color space can be transformed to another.  \n\nIn the example here the image was taken with a Sony a6300 using Picture profile1, Gamma: S-log3, Color Mode: S-Gamut3.Cine\n\nBy default the OpenColorIO TOP comes with only a small number of LUTs that are built in. The closest input LUT is SLog and the correct way to output the image for viewing in TouchDesigner is linear.  See the Color Space Transform page of each TOP and you will see these settings.\n\nThe image when its loaded is quite dull. However this image is a 16bit TIFF and the color values are stored in such a way as to maintain the most color information. Through the muse of a LUT the Slog stored colors and viewed better in TouchDesigner with an output LUT for linear.\n\ngithub with many more LUTs...\nhttps://github.com/imageworks/OpenColorIO-Configs\n\nGood collection found in above github is aces_1.0.3 which is latest color grading kit from Academy of Motion Picture Arts and Sciences https://en.wikipedia.org/wiki/Academy_Color_Encoding_System\n\nLoad the aces_1.0.3 configuration file in the aces_1.0.3 folder in the git repository and select the config.ocio.\n\nThe following LUTs will be available.\n\nInput LUT - Sony-S-Log3-S.Gamut3.Cine\nOutput LUT - Utility-Linear-sRGB"
                    }
                }
            }
        },
        "opviewerTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "basic",
                    "author": "raganmd",
                    "readme": {
                        "en": "The OP Viewer TOP allows you to produce a texture out of any operator. Here we can see a display being rendered from a CHOP, SOP, and DAT. This example multiples the node height and width by 4 - this maintains the aspect ratio while simultaneously increasing the display size.\n\nMatthew Ragan\n8/13/14\n\nOn the TOPs' Commpn page, change Viewer Smoothness to Mipmap Pixels to make the viewer look smoother with those thin lines. That's purely cosmetic. It does't affect the image that the TOP outputs. (gh)"
                    }
                }
            }
        },
        "overTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "pre fit",
                    "author": "",
                    "readme": {
                        "en": "The Pre Fit parameters give you various options to how the compositing will occur. "
                    }
                },
                "1": {
                    "title": "resolution",
                    "author": "",
                    "readme": {
                        "en": "A handy trick to scale content to a  specific resolution is to use an Over TOP. \n\nBut you can more easily feed the Movie File In TOP to a Constant TOP, or mroe easily yet, use a Fit TOP."
                    }
                },
                "2": {
                    "title": "fit outside",
                    "author": "",
                    "readme": {
                        "en": "Fit Outside is useful in situations where you'd like to overlay one image onto another completely, and removes the chance of any edges being missed.\n\nBetter yet, see the Fit TOP."
                    }
                }
            }
        },
        "packTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "pack",
                    "author": "",
                    "readme": {
                        "en": "Pack is used to put 32-bit RGBA floating point images into quadruple-wide 8-bit fixed point image to make them more transportable through lossless file formats that are just 8-bit, or 8-bit protocols like Spout/Siphon. Then the Pack TOP can unpack on the other side.\n\n\nIn the second example, we just do it to a single floating point channel, reorder_32BitRedOnly gets the blue channel only, and outputs a single-channel TOP (see its Pixel Format parameter). Then we pack that single channel into 8-bit form (pack_8BitMono). Then we unpack it as a mono floating point channel. The last reorder takes that one channel and puts it as the blue channel of an RGBA 32-bit image.\n\nIn the packed format, every 32-bit pixel is converted to 4 8-bit pixels. It's lossless.\n"
                    }
                },
                "1": {
                    "title": "pack analyze",
                    "author": "",
                    "readme": {
                        "en": "ramp1 is normal RGBA 8-bit.\n\nramp2 is 1-channel 8-bit.\n\nramp3 is 1-channel 32-bit float. You can see its better precision in the ramp.\n\nramp3 is in a similar format that you would have for a depth map or a point cloud.\n\npack1 puts ramp3 into an RGBA 8-bit image that can be commonly saved in a file.\n\nRight-click on the node and Save Image...\n\nor you can write it out with the Movie File Out TOP.\n"
                    }
                }
            }
        },
        "pointfileinTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "reading point files",
                    "author": "",
                    "readme": {
                        "en": "Point File In TOP reads a .ply point cloud file.\n\ninfo1 shows that it has 10 channels including point colors in 'red', 'green' and 'blue' channels.\n\ninfo2 shows number of points.\n\nMost TOPs can only hold up to 4 channels, so null1 gets the first 4, which are X Y Z and 'active'. \n\n'active' (in the alpha channel of the image) is a channel that indicates if the pixel is a valid point or not (orange = Nan = not a point).\n\npointfileselect1 is used to get the other channels into a TOP... in this case, the channels it selects are the point colors - 'red', 'green', 'blue' as they are named in the file.\n\nThe colors in the .ply file are 0-255 so math1 scales them down to 0-1.\n\ngeo1 contains one point that is converted to a 1-point particle system, needed to render Line MAT from TOPs.\n"
                    }
                },
                "1": {
                    "title": "point thinning",
                    "author": "",
                    "readme": {
                        "en": "The resolution is reduced via the Output Resolution menu on the Common page to 1/4 by 1/4 = 1/16 the number of points in the file. \n\nThis is shown in info2 and the eval1, eval2 expressions."
                    }
                }
            }
        },
        "projectionTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "projection conversions",
                    "author": "",
                    "readme": {
                        "en": "cubeMap is a 6-camera-in-one rendering created with the Render TOP.\n\nIt renders the entire view around the camera.\n\nprojection1 need the Projection Type parameter to be set to the input's type, and its output in this case is Equirectangular.\n\nYou need to set its resolution and aspect ratio on the Common page.  The Rotate parameter lets you specify which direction is \"staight ahead\".\n\nprojection2 converts the Equirectangular map to a Fish-Eye.  Again, the Rotate parameter lets you specify which direction is \"staight ahead\".\n\nAlso Fish-Eye lets you select what the viewing angle is to the perimeter outer ring, default 180 degrees.\n\nprojection3 is the same thing but it gets its input from the cube map. projection4 is rotated to look behind.\n\n\n"
                    }
                },
                "1": {
                    "title": "from equirectangular",
                    "author": "",
                    "readme": {
                        "en": "This converts from an existing equirectangular image.\n\nprojection3 has its resolution and aspect ratio changed on the Common page.\n\nprojection4 is rotated to be looking down-up along the horizontal center line. Same as projection5.  They are both equiractangulars too.\n\nSee also the Cube Map TOP.\n\n"
                    }
                },
                "2": {
                    "title": "cartesian xy to polar",
                    "author": "",
                    "readme": {
                        "en": "here the Cartesian-to-Polar conversion\n\nThe Projection TOP needs it input flipped first to get the ramp to go clockwise. Bypass it to make it go counter-clockwise.\n\n\n"
                    }
                }
            }
        },
        "rampTOP": {
            "num_samples": 4,
            "examples": {
                "0": {
                    "title": "circle",
                    "author": "",
                    "readme": {
                        "en": "Ramp TOPs can be used to create circles.\n\nExtend Left parameter is set to Zero and Interpolate Notches is set to Step.\n\nBut now we have the Circle TOP!"
                    }
                },
                "1": {
                    "title": "table",
                    "author": "",
                    "readme": {
                        "en": "You can edit the individual values of the ramp via its docked table. Try changing the R G or B values in the table."
                    }
                },
                "2": {
                    "title": "phase",
                    "author": "",
                    "readme": {
                        "en": "You can animate a ramp's phase "
                    }
                },
                "3": {
                    "title": "procedural ramp",
                    "author": "",
                    "readme": {
                        "en": "You can procedurally generate tables for ramps. In this case the panel \"bicolor\" u and v define an inner and outer hue, which is generated with an  expression for the red channel in an Evaluate DAT.\n\nThe ramp is converted from hue-saturation-value to RGB in an HSV to RGB TOP."
                    }
                }
            }
        },
        "remapTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "simple",
                    "author": "",
                    "readme": {
                        "en": "Remap TOP ramps are 32-bit.\n\nprepared by David Braun"
                    }
                }
            }
        },
        "renderTOP": {
            "num_samples": 5,
            "examples": {
                "0": {
                    "title": "basic render",
                    "author": "",
                    "readme": {
                        "en": "The Render TOP renders a 3D scene with a camera and lights into a 2D texture. \n\nA standard render setup includes a geometry object, a camera, light, and a material.\n\nYou can wire a SOP to the input of geo1 to replace to torus.\n\nsee sopRender in Palette's Tools for a more packaged setup."
                    }
                },
                "1": {
                    "title": "render options",
                    "author": "",
                    "readme": {
                        "en": "This setup is being rendered in a number of different ways to demonstrate some  of the functionality of the Render TOP"
                    }
                },
                "2": {
                    "title": "shadows",
                    "author": "",
                    "readme": {
                        "en": "Notice that the lights are using a lookat to point at the geometry. This is nessesary to create a proper shadow map, which is rendered from the light's point of view. You then also want to adjust the FOV of the lights camera parameters on the View page to tighten the light's view, so the shadow map has better resolution on the area's you are interested in."
                    }
                },
                "3": {
                    "title": "depth",
                    "author": "",
                    "readme": {
                        "en": "You can use the Depth TOP to get the depth buffer for both a Render TOP, as well as the shadow map from a light that is doing shadowing. Usually a Depth map will look mostly white, with much of the information between 0.9 and 1.0. You can visually make it more informative by tightening the near/far planes for the camera/light."
                    }
                },
                "4": {
                    "title": "cube map",
                    "author": "",
                    "readme": {
                        "en": "The Render TOP renders a 3D scene as a cube map, which is 6 renders-in-one, using the Render Mode parameter.\n\nIn this case the camera and light are at 0, 0, 0 and the geometry is around it in all directions.\n\nSee also the Projection TOP to convert between different projection types.\n\nThe image aspect ratio is 3x4.\n\nSee also the Cube Map TOP and the Projection TOP."
                    }
                }
            }
        },
        "renderpassTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "render pass",
                    "author": "",
                    "readme": {
                        "en": "The Render Pass TOP can be used to render additional geometry into the same buffer. You can optionally turn on clearing the depth or color buffers depending on if you want to add more geometry to the existing scene taking depth into account, render the geometry ontop of the existing scene as an overlay, or simply rendering a new scene and clearing the old scene."
                    }
                }
            }
        },
        "reorderTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "channels",
                    "author": "",
                    "readme": {
                        "en": "This is a simple example of how to assign incoming RGBA channels to outgoing RGBA channels.\n\nIn the example, the output Red channel is the 2nd input's Red channel, the output Green channel is the 3rd input's Green channel, the output Blue channel is the 1st input's Blue channel, and the alpha is the 4th input's alpha.\n\nThe Math TOP multiplies RGB by alpha to conform to the TouchDesigner image standard of \"pre-multiplied by alpha\", where red, green and blue are always less than alpha."
                    }
                },
                "1": {
                    "title": "mattes",
                    "author": "",
                    "readme": {
                        "en": "Reorder is helpful for creating alpha masks by using the input's alpha channel as all the output channels."
                    }
                },
                "2": {
                    "title": "pull channels",
                    "author": "",
                    "readme": {
                        "en": "Reorder can pull individual channels.\n\nIn the first case it preserves the red channel, and sets the green and blue channels to 0. It also sets the alpha to 1 making the resulting image opaque.\n\nIn the second case it also converts the image to one-channel versus the ususal 4-channel RGBA. This is done on any TOP's Common page in the Pixel Format menu, \n\nThe third case shows that the first channel is used for the mono channel: Green is pulled into the first channel and the image converted to mono,"
                    }
                }
            }
        },
        "resolutionTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "resolution",
                    "author": "",
                    "readme": {
                        "en": "This example brings the resolution down to 1/4 of it's original value. "
                    }
                },
                "1": {
                    "title": "input",
                    "author": "",
                    "readme": {
                        "en": "You can use the Resolution TOP to change the input smoothness settings."
                    }
                },
                "2": {
                    "title": "viewer smoothness",
                    "author": "",
                    "readme": {
                        "en": "The two images are the same.\n\nIt is only the viewers that are set differently. The second TOP has its Viewer Smoothness set to Mip Map, which makes images look better when you zoom back from them.\n\nThe Viewer Smoothness parameter is on all TOPs."
                    }
                }
            }
        },
        "rgbkeyTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "alpha where RGB in range",
                    "author": "nettoyeur",
                    "readme": {
                        "en": "The RGB Key TOP \"pulls a key\" from the image using the Red, Green, and Blue channel settings. If a pixel value is between the Min and Max parameters for all three settings, then its alpha is set to 1.\n\nThe first three examples are each set to a different color. for rgbkey1, red has to be above .5, green below .1, and blue below .1.\n\nYou can also use this operator to hide certain colors. See rgbkey3_invert, it has exactly the same Red, Green, and Blue settings as rgbkey3, but it has its alpha inverted using Invert New Alpha.\n\nSee also the Chroma Key TOP and in the Palette, the Chromakey component.\n\nIdzard Kwadijk\nkwadijk@idzard.com\n "
                    }
                }
            }
        },
        "rgbtohsvTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "rgb to hsv to rgb",
                    "author": "",
                    "readme": {
                        "en": "rgbhsv TOP converts pixels so that the hue is in  the red channel, the saturation is in the green channel, and the value (brightness) is in  the blue channel.\n\nAfter converting to hsv,level_increase_saturation  alters the g (saturation) channel via the Gamma parameter, where 0 saturation and 1 saturation remain unchanged, but all other values are cranked  up toward 1.\n\n After converting to hsv, level_push_color alters r (hue) channel so the values are in a smaller range (.1 to .2).\n\n After converting to hsv level_quantize_hue_and_value quantizes hue and saturation by using the Step parameters. The Channel Mask parameter on  the Common page quantizes in .25 steps the  red (hue) and blue (brightness) channels.\n\nThe last two examples show blurring of hue and saturation by masking blue or red channels.\n\nNote: All the above get converted from hsv to rgb."
                    }
                },
                "1": {
                    "title": "squeeze hue to limited range",
                    "author": "greg",
                    "readme": {
                        "en": "This is a useful trick to squeeze the range of colors in an image down to a smaller range (artificial of course). Like all colors fit into the yellow-to-green range.\n\nDrag-drop the Movie File In TOPs to select1 to see what it does.\n\nThen to adjust the range, right-click on hueControls and select View... to get the panel in a floating window. Then adjust Hue Midpoint. \n\nHue Divider needs to be an integer for this to work well. Hue Divider of 5 causes the hue range to be 1/5 the full color range, 8 reduces the range to 1/8, etc.  The higher the number, the more single-color the result is.\n\nAnother trick: hueControls is a set of parameters, and the UI of hueControls is defined with a Parameter COMP that is located inside hueControls, and exposed via the Operator Viewer parameter on hueControls (slight brain-twister)."
                    }
                }
            }
        },
        "selectTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "local select",
                    "author": "",
                    "readme": {
                        "en": "Select TOPs allow you to select any TOP in any network.\n\nIt is good practice to use a renamed Null TOP to capture adjustments/additional nodes you may add later."
                    }
                },
                "1": {
                    "title": "select from anywhere",
                    "author": "",
                    "readme": {
                        "en": "Select TOPs allow you to select any TOP in any network.\n\nIt is good practice to use a renamed Null TOP to capture adjustments/additional nodes you may add later."
                    }
                },
                "2": {
                    "title": "multi-select expression",
                    "author": "",
                    "readme": {
                        "en": "Select TOPs allow you to select any TOP in any network.\n\nIt is good practice to use a renamed Null TOP to capture adjustments/additional nodes you may add later."
                    }
                }
            }
        },
        "switchTOP": {
            "num_samples": 3,
            "examples": {
                "0": {
                    "title": "no blend",
                    "author": "",
                    "readme": {
                        "en": "This example snaps between inputs."
                    }
                },
                "1": {
                    "title": "blend",
                    "author": "",
                    "readme": {
                        "en": "This example blends between inputs smoothly in a cycle of 4 images. \n\nIt uses tricky technique to handle the case of going from the last image back to the first image without passing through the other 2 images. There must be a better way!\n\nThe switch_blend also forces the resolution to be 1280x720. Otherwise its output res switches between the various resolutions of the inputs"
                    }
                },
                "2": {
                    "title": "simple switch",
                    "author": "",
                    "readme": {
                        "en": "This is a better way to blend without using the expression and Execute DAT.\n\nNote the expression in count1 to calculat ethe number of inputs to the Switch TOP. matt r"
                    }
                }
            }
        },
        "textTOP": {
            "num_samples": 7,
            "examples": {
                "0": {
                    "title": "from dat",
                    "author": "",
                    "readme": {
                        "en": "This is helpful for rending information held in DATs, which can then be composited into your final output."
                    }
                },
                "1": {
                    "title": "table",
                    "author": "",
                    "readme": {
                        "en": "This example reads directly from a specific cell in a table."
                    }
                },
                "2": {
                    "title": "chops",
                    "author": "",
                    "readme": {
                        "en": "This example renders information directly from a CHOP"
                    }
                },
                "3": {
                    "title": "external font",
                    "author": "",
                    "readme": {
                        "en": "TouchDesigner supports loading of external font files. This is useful if you're moving the project to different computers and you're unsure if the selected font is available on all computers. (font file not available)"
                    }
                },
                "4": {
                    "title": "formatting",
                    "author": "",
                    "readme": {
                        "en": "You can format various aspects of the text."
                    }
                },
                "5": {
                    "title": "colors",
                    "author": "",
                    "readme": {
                        "en": "You can change text, background and border colors.\n\nBorder A and B are single-pixel wide."
                    }
                },
                "6": {
                    "title": "variable height",
                    "author": "",
                    "readme": {
                        "en": "If you want to minumize memory when rendering multi-line text, use op('text1').textHeight, which pre-computes the expected height of the text based on width, font, spacing etc.\n\n(If that gives a warning, make eval1 point to text1, which does the same calculation.)"
                    }
                }
            }
        },
        "texture3dTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "3D texture from stills",
                    "author": "",
                    "readme": {
                        "en": "To create a 3D texture, you need to fill the Texture 3D TOP with a sequence of 2D images, in this case 6 of them.\n\nTo create the 3D teture: You \"pre-fill\" tex3d1 by turning on Pre Fill or pulsing Pre Fill. The TOP automatically goes to frame 1 on the timeline, cooks the image that feeds into the tex3d1 TOP, tex3d1 captures it as it first slice, then it goes to frame 2 and cooks the image again, until all 6 images are cooked. Cache size here is 6.\n\nSo the way to make all the images different is to put \"me.time.frame\" in the the Switch TOP that feed into tex3d1.\n\nYou can leave Pre-Fill on, it will cook once after you start your .toe file, or you can click the Pulse button to cook it when you change OPs in your network feeding into the CHOP.\n\ntex3d1 is used in the material for the Geometry COMP's instancing. The Geometry COMP's W parameter refers to the w channel of \"instancer\", which contains the slice number in the w channel, going from 0 to 5."
                    }
                },
                "1": {
                    "title": "3D texture from movie",
                    "author": "",
                    "readme": {
                        "en": "To create a 3D texture, you need to fill it with a sequence of 2D images, in this case 32 of them.\n\nThe way it's done now is to imagine it's building the 32 images by going to frame 1 on the timeline,cooking the image that feeds into the tex3d1 TOP, then going to frame 2 and cooking the image again,until all 32 images are cooked.\n\nSo the way to make all the images different is to put \"me.time.frame\" in the OPs that feed into tex3d1.\n\nIn this case, moviefilein1 has me.time.frame in the Index parameter to get the first image of the movie ontimeline frame 1. That parameter's index units is set to \"I\" (index), in case the movie has a different frames per second (such as 25 images per second) than the timeline.  So frame 23 is always going to be image 22 of the file (where index starts at 0, frame starts at 1).  In this way, no images are missed or duplicated in the 3D teture.\n\nThe HSV Adjust TOP also has an expression involving me.time.frame, where it goes through the full color wheel in 32 steps.\n\nYou can leave Pre-Fill on, it will cook once after you start your .toe file, or you can click the Pulse button to cook it when you change OPs in your network feeding into the CHOP."
                    }
                }
            }
        },
        "tileTOP": {
            "num_samples": 2,
            "examples": {
                "0": {
                    "title": "seamless textures",
                    "author": "",
                    "readme": {
                        "en": "The main purpose of the Tile TOP is to produce seamless texture maps from most images.\n\nOnce you are happy with its look as a 2x2 tile, you can switch it to a 1x1 to get the most out of your memory, and then use it as a texture elsewhere.  Try it on sopRender in Tools in the Dialogs -> Palette."
                    }
                },
                "1": {
                    "title": "tile",
                    "author": "raganmd",
                    "readme": {
                        "en": "The Tile TOP, like its name suggests, will create a tiled image. This can make for some interesting kaleidoscopic effects. Here you can see four examples of how you might use the tile effect to create repeated patterns. Use the buttons to switch between using the photo and the ramp to see different effects. You might also use the bypass button to see what happens if you turn off the spin effect.\n\nMatthew Ragan 8/16/14"
                    }
                }
            }
        },
        "timemachineTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "time machine",
                    "author": "",
                    "readme": {
                        "en": "The Time Machine TOP is always used with the Texture 3D TOP. (See the snippets for Texture 3D TOP.)\n\nThe 3D texture is loaded (via Pre Fill, which runs the timeline from frame 1 to frame (cache size * step size = 32 frames here) and  puts it in a 3D texture.\n\nThe Time Machine TOP fetches from the 3D texture. Where level2 is black, it gets from the lower slices of the 3D texture. Where it is white it get from the upper slices of the 3D texture.\n\nThat is, each pixel of the output uses a slice of the 3D texture based on the grey-scale value of the 2nd input (the ramp).\n\nYou can adjust the lower and upper range of the ramp, which restricts which slices in the 3D texture it retrieves from."
                    }
                }
            }
        },
        "transformTOP": {
            "num_samples": 6,
            "examples": {
                "0": {
                    "title": "pivot",
                    "author": "",
                    "readme": {
                        "en": "The Transform's Pivot paramter controls where in the image the rotation is centered."
                    }
                },
                "1": {
                    "title": "transform order",
                    "author": "",
                    "readme": {
                        "en": "The transform order is crucial for assigning the order of the Transform TOP's operations.\n\ntransform1 (deafault) rotates first then translates.  transform2 (via Transform Order menu) translates first and then rotates."
                    }
                },
                "2": {
                    "title": "background",
                    "author": "",
                    "readme": {
                        "en": "You can fill backgrounds with the Background parameters."
                    }
                },
                "3": {
                    "title": "scale",
                    "author": "",
                    "readme": {
                        "en": "You can perform simple scaling  in a Transform TOP"
                    }
                },
                "4": {
                    "title": "extend, tile and scroll",
                    "author": "",
                    "readme": {
                        "en": "The extend conditions are used whenever you create blank space using the Transform TOP.\n\nWhen you want seamless repeating textures, use the Tile TOP."
                    }
                },
                "5": {
                    "title": "when to mip map",
                    "author": "",
                    "readme": {
                        "en": "Each Transform TOP is setting the resolution down to 1/16 the original resolution (80 pixels in x).\n\nTo see the indiviual pixels more clearly, on the Common page on transform1, Viewer Smoothness is set to Nearest Pixel.\n\nAnother way to see individual pixels is to turn on Viewer Active (bottom right flag on the nodem transform2), then right-click on the image and set Display Pixel Values. That also shows the pixel values at the bottom left of the image.\n\nMiddle-mouse-click on the transform2 image to zoom into pixels.  'h' to home.\n\nNone of the above affects the data in the pixels, it only affects how you see them in the viewer.\n\nOn the other hand, transform4 affects the pixel values because Input Smoothness is set to Mipmap pixels. (Check 'mipmap\" in Wikipedia.) Because the input is scaled down so much, transform4 combines 16x16 = 256 pixels into one by averaging them, but the others take only one pixel from the input as its value for an output pixel.\n\ntransform5 and transform6 show how, even when the resolution of the output is the same as the input, turning on Mipmap on Input Smoothness in transform6 makes 10 pixels averages into 1 pixel of the output,"
                    }
                }
            }
        },
        "videodeviceinTOP": {
            "num_samples": 1,
            "examples": {
                "0": {
                    "title": "video in",
                    "author": "",
                    "readme": {
                        "en": "Assuming you have a camera on this computer,\n\nSelect a device and set Active to On.\n\nThen click on Options to adjust your camera's settings. "
                    }
                }
            }
        }
    }
}